{
  "_args": [
    [
      {
        "raw": "crocks",
        "scope": null,
        "escapedName": "crocks",
        "name": "crocks",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/Sung/Desktop/state_monad"
    ]
  ],
  "_from": "crocks@latest",
  "_id": "crocks@0.8.1",
  "_inCache": true,
  "_location": "/crocks",
  "_nodeVersion": "6.2.2",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/crocks-0.8.1.tgz_1510727308457_0.8800676306709647"
  },
  "_npmUser": {
    "name": "evil",
    "email": "evilsoft@aol.com"
  },
  "_npmVersion": "3.10.5",
  "_phantomChildren": {},
  "_requested": {
    "raw": "crocks",
    "scope": null,
    "escapedName": "crocks",
    "name": "crocks",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/crocks/-/crocks-0.8.1.tgz",
  "_shasum": "d85a35141ee2e9dfd31d16f60f596091f9c967b4",
  "_shrinkwrap": null,
  "_spec": "crocks",
  "_where": "/Users/Sung/Desktop/state_monad",
  "author": {
    "name": "Ian Hofmann-Hicks",
    "email": "evilsoft@aol.com",
    "url": "evil"
  },
  "bugs": {
    "url": "https://github.com/evilsoft/crocks/issues"
  },
  "dependencies": {},
  "description": "A collection of well known Monadic Containers for your utter enjoyment.",
  "devDependencies": {
    "buble": "^0.15.2",
    "coveralls": "^2.11.15",
    "eslint": "^3.19.0",
    "nodemon": "^1.9.2",
    "nyc": "^10.1.2",
    "sinon": "^2.1.0",
    "tap-spec": "^4.1.1",
    "tape": "^4.6.0",
    "uglify-js": "^2.7.0",
    "webpack": "^2.3.3"
  },
  "directories": {},
  "dist": {
    "shasum": "d85a35141ee2e9dfd31d16f60f596091f9c967b4",
    "tarball": "https://registry.npmjs.org/crocks/-/crocks-0.8.1.tgz"
  },
  "homepage": "https://github.com/evilsoft/crocks#readme",
  "keywords": [
    "FP",
    "Functional",
    "Monadic",
    "Monads",
    "fantasy",
    "Applicative",
    "Functor"
  ],
  "license": "ISC",
  "main": "./index.js",
  "maintainers": [
    {
      "name": "evil",
      "email": "evilsoft@aol.com"
    }
  ],
  "name": "crocks",
  "nyc": {
    "check-coverage": true,
    "lines": 100,
    "statements": 100,
    "functions": 100,
    "branches": 100,
    "exclude": [
      "src/",
      "build/test/",
      "**/*.spec.js"
    ]
  },
  "optionalDependencies": {},
  "readme": "[![Build Status](https://travis-ci.org/evilsoft/crocks.svg?branch=master)](https://travis-ci.org/evilsoft/crocks) [![Coverage Status](https://coveralls.io/repos/github/evilsoft/crocks/badge.svg?branch=master)](https://coveralls.io/github/evilsoft/crocks?branch=master)\n[![Join the chat at https://gitter.im/crocksjs/crocks](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/crocksjs/crocks?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![NPM version](https://badge.fury.io/js/crocks.svg)](https://www.npmjs.com/package/crocks)\n\n# crocks.js\n`crocks` is a collection of popular *Algebraic Data Types (ADTs)* that are all\nthe rage in functional programming. You have heard of things like `Maybe` and\n`Either` and heck maybe even `IO`, that is what these are. The main goal of\n`crocks` is to curate and provide not only a common interface between each type\n(where possible of course), but also all of the helper functions needed to hit\nthe ground running.\n\n## Installation\n`crocks` is available from `npm` and is just a shell command away. All you need\nto do is run the following to save it as a dependency in your current project\nfolder:\n\n```\n$ npm install crocks -S\n```\n\nThis will pull down `crocks` into your project's `node_modules` folder and can\nbe accessed by adding something like the following in the file that needs it:\n\n```javascript\n// node require syntax\nconst crocks = require('crocks')\n\n// Javascript modules (if you are transpiling)\nimport crocks from 'crocks'\n```\n\nThis lib *should* work, with no additional compilation in all current browsers\n(Edge, Safari, Chrome, Firefox), if it does not, please file an issue as I\nreally, really want it to. :smile_cat:.\n\nThere is a lot to this library, and as such it may not be desired to bring in\nthe entire library when bundling for a library or a frontend application. If\nthis is the case, the code is organized in a manner groups all types in\nfunctions that construct those type in their own folders. The general purpose\nfunctions are spread across the following folders: `combinators`, `helpers`,\n`logic`, `pointfree` and `predicates`.\n\nTo access the types, just reference the folder like: `crocks/Maybe`, or\n`crocks/Result`. If you want to access a function that constructs a given type,\nreference it by name, like: `crocks/Maybe/safe` or `crocks/Result/tryCatch`.\nThis organization helps ensure that you only include what you need.\n\nAnother thing to note is, if you are transpiling, then destructuring in your\n`import` statement is not going to work as you are thinking (maybe if you are\nusing `babel`, but this will be broken once modules are available in node, so\nbe careful). Basically you should not do this, as `crocks` will not be set up\nfor it until modules are available in node:\n\n```javascript\n// Nope! Nope! Nope!:\nimport { Maybe, compose, curry, map } from 'crocks'\n\n// instead do something like this:\nimport crocks from 'crocks'\nconst { Maybe, compose, curry, map } = crocks\n\n// do not wanna bring all of crocks into your bundle?\n// I feel ya, all try this:\n\nimport Maybe from 'crocks/Maybe'\nimport compose from 'crock/helpers/compose'\nimport curry from 'crocks/helpers/curry'\nimport map from 'crocks/pointfree/map'\n\n// you can of course do the same with require statements:\nconst All = require('crocks/All')\n...\n```\n\n## What is in this?\nThere are (8) classifications of \"things\" included in this library:\n\n* [Crocks](#crocks): These are the ADTs that this library is centered around.\nThey are all `Functor` based Data Types that provide different computational\ncontexts for working in a more declarative, functional flow. For the most part,\na majority of the other bits in `crocks` exist to serve these ADTs.\n\n* [Monoids](#monoids): These helpful ADTs are in a class of their own, not\nreally `Functor`s in their own right (although some can be), they are still very\nuseful in our everyday programming needs. Ever need to Sum a list of Numbers or\nmix a mess of objects together? This is were you will find the ADTs you need to\ndo that.\n\n* [Combinators](#combinators): A collection of functions that are used for\nworking with other functions. These do things like compose (2) functions\ntogether, or flip arguments on a function. They typically either take a\nfunction, return a function or a bit a both. These are considered the glue that\nholds the mighty house of `crocks` together and a valuable aid in writing\nreusable code.\n\n* [Helper Functions](#helper-functions): All other support functions that are\neither convenient versions of combinators or not even combinators at all cover\nthis group.\n\n* [Logic Functions](#logic-functions): A helpful collection of Logic based\ncombinators. All of these functions work with predicate functions and let you\ncombine them in some very interesting ways.\n\n* [Predicate Functions](#predicate-functions): A helpful collection of predicate\nfunctions to get you started.\n\n* [Point-free Functions](#point-free-functions): Wanna use these ADTs in a way\nthat you never have to reference the actual data being worked on? Well here is\nwhere you will find all of these functions to do that. For every algebra\navailable on both the `Crocks` and `Monoids` there is a function here.\n\n* [Transformation Functions](#transformation-functions): All the functions found\nhere are used to transform from one type to another, naturally. These come are\nhandy in situations where you have functions that return one type (like an\n`Either`), but are working in a context of another (say `Maybe`). You would\nlike to compose these, but in doing so will result in a nesting that you will\nneed to account for for the rest of your flow.\n\n### Crocks\nThe `crocks` are the heart and soul of this library. This is where you will find\nall your favorite ADT's you have grown to :heart:. They include gems such as:\n`Maybe`, `Either` and `IO`, to name a few. The are usually just a simple\nconstructor that takes either a function or value (depending on the type)\nand will return you a \"container\" that wraps whatever you passed it. Each\ncontainer provides a variety of functions that act as the operations you can do\non the contained value. There are many types that share the same function names,\nbut what they do from type to type may vary.  Every Crock provides type function\non the Constructor and both inspect and type functions on their Instances.\n\nAll `Crocks` are Constructor functions of the given type, with `Writer` being an\nexception. The `Writer` function takes a [`Monoid`](#monoids) that will\nrepresent the `log`. Once you provide the [`Monoid`](#monoids), the function\nwill return the `Writer` Constructor for your `Writer` using that specific\n[`Monoid`](#monoids).\n\n| Crock | Constructor | Instance |\n|---|:---|:---|\n| `Arrow` | `id` | `both`, `compose`, `contramap`, `empty`, `first`, `map`, `promap`, `runWith`, `second` |\n| `Async` | `Rejected`, `Resolved`, `all`, `fromNode`, `fromPromise`, `of` | `alt`, `ap`, `bimap`, `chain`, `coalesce`, `fork`, `map`, `of`, `swap`, `toPromise` |\n| `Const` | -- | `ap`, `chain`, `concat`, `equals`, `map`, `valueOf` |\n| `Either` | `Left`, `Right`, `of`| `alt`, `ap`, `bimap`, `chain`, `coalesce`, `concat`, `either`, `equals`, `map`, `of`, `sequence`, `swap`, `traverse` |\n| `Identity` | `of` | `ap`, `chain`, `concat`, `equals`, `map`, `of`, `sequence`, `traverse`, `valueOf` |\n| `IO` | `of` | `ap`, `chain`, `map`, `of`, `run` |\n| `List` |  `empty`, `fromArray`, `of` | `ap`, `chain`, `concat`, `cons`, `empty`, `equals`, `filter`, `head`, `map`, `of`, `reduce`, `reject`, `sequence`, `tail`, `toArray`, `traverse`, `valueOf` |\n| `Maybe` | `Nothing`, `Just`, `of`, `zero` | `alt`, `ap`, `chain`, `coalesce`, `concat`, `equals`, `either`, `map`, `of`, `option`, `sequence`, `traverse`, `zero` |\n| `Pair` | --- | `ap`, `bimap`, `chain`, `concat`, `equals`, `extend`, `fst`, `map`, `merge`, `of`, `snd`, `swap`, `toArray` |\n| `Pred` * | `empty` | `concat`, `contramap`, `empty`, `runWith`, `valueOf` |\n| `Reader` | `ask`, `of`| `ap`, `chain`, `map`, `of`, `runWith` |\n| `Result` | `Err`, `Ok`, `of`| `alt`, `ap`, `bimap`, `chain`, `coalesce`, `concat`, `either`, `equals`, `map`, `of`, `sequence`, `swap`, `traverse` |\n| `Star` | `id` | `both`, `compose`, `contramap`, `map`, `promap`, `runWith` |\n| `State` | `get`, `modify` `of`, `put`| `ap`, `chain`, `evalWith`, `execWith`, `map`, `of`, `runWith` |\n| `Unit` | `empty`, `of` | `ap`, `chain`, `concat`, `empty`, `equals`, `map`, `of`, `valueOf` |\n| `Writer`| `of` | `ap`, `chain`, `equals`, `log`, `map`, `of`, `read`, `valueOf` |\n\n\\* based on [this article](https://medium.com/@drboolean/monoidal-contravariant-functors-are-actually-useful-1032211045c4#.polugsx2a)\n\n### Monoids\nEach `Monoid` provides a means to represent a binary operation and is usually\nlocked down to a specific type. These are great when you need to combine a list\nof values down to one value. In this library, any ADT that provides both an\n`empty` and `concat` function can be used as a `Monoid`. There are a few of the\n[`crocks`](#crocks) that are also monoidial, so be on the look out for those as\nwell. All `Monoids` work with the point-free functions [`mconcat`](#mconcat),\n[`mreduce`](#mreduce), [`mconcatMap`](#mconcatmap) and\n[`mreduceMap`](#mreducemap).\n\nAll `Monoids` provide `empty` and `type` function on their Constructors as well\nas the following Instance Functions: inspect, `type`, `valueOf`, `empty` and\n`concat`.\n\n\n| Monoid | Type | Operation | Empty (Identity) |\n|---|---|---|---|\n| `All` | Boolean | Logical AND | `true` |\n| `Any` | Boolean | Logical OR | `false` |\n| `Assign` | Object | `Object.assign` | `{}` |\n| `Endo` | Function | `compose` | `identity` |\n| `First` | Maybe | First `Just` | `Nothing` |\n| `Last` | Maybe | Last `Just` | `Nothing` |\n| `Max` | Number | `Math.max` | `-Infinity` |\n| `Min` | Number | `Math.min` | `Infinity` |\n| `Prod` | Number | Multiplication | `1` |\n| `Sum` | Number | Addition | `0` |\n\n### Combinators\n#### applyTo\n`crocks/combinators/applyTo`\n```haskell\napplyTo :: (a -> b) -> a -> b\n```\nSeems really silly, but is quite useful for a lot of things. It takes a function\nand a value and then returns the result of that function with the argument\napplied.\n\n#### composeB\n`crocks/combinators/composeB`\n```haskell\ncomposeB :: (b -> c) -> (a -> b) -> a -> c\n```\nProvides a means to describe a composition between two functions. it takes two\nfunctions and a value. Given `composeB(f, g)`, which is read `f` after `g`, it\nwill return a function that will take value `a` and apply it to `g`, passing the\nresult as an argument to `f`, and will finally return the result of `f`. (This\nallows only two functions, if you want to avoid things like:\n`composeB(composeB(f, g), composeB(h, i))` then check out\n[`compose`](#compose).)\n\n#### constant\n`crocks/combinators/constant`\n```haskell\nconstant :: a -> _ -> a\n```\nThis is a very handy dandy function, used a lot. Pass it any value and it will\ngive you back a function that will return that same value no matter what you\npass it.\n\n#### flip\n`crocks/combinators/flip`\n```haskell\nflip :: (a -> b -> c) -> b -> a -> c\n```\nThis little function just takes a function and returns a function that takes the\nfirst two parameters in reverse. One can compose flip calls down the line to\nflip all, or some of the other parameters if there are more than two. Mix and\nmatch to your :heart:'s desire.\n\n#### identity\n`crocks/combinators/identity`\n```haskell\nidentity ::  a -> a\n```\nThis function and [`constant`](#constant) are the workhorses of writing code\nwith this library. It quite simply is just a function that when you pass it\nsomething, it returns that thing right back to you. So simple, I will leave it\nas an exercise to reason about why this is so powerful and important.\n\n#### reverseApply\n`crocks/combinators/reverseApply`\n```haskell\nreverseApply :: a -> (a -> b) -> b\n```\nEver run into a situation where you have a value but do not have a function to\napply it to? Well this little bird, named Thrush, is there to help out. Just\ngive it a value and it will give you back a function ready to take a function.\nOnce that function is provided, it will return the result of applying your value\nto that function.\n\n#### substitution\n`crocks/combinators/substitution`\n```haskell\nsubstitution :: (a -> b -> c) -> (a -> b) -> a -> c\n```\nWhile it a complicated little bugger, it can come in very handy from time to\ntime. In it's first two arguments it takes functions. The first must be binary\nand the second unary. That will return you a function that is ready to take some\nvalue. Once supplied the fun starts, it will pass the `a` to the first argument\nof both functions, and the result of the second function to the second parameter\nof the first function. Finally after all that juggling, it will return the\nresult of that first function. When used with partial application on that first\nparameter, a whole new world of combinatory madness is presented!\n\n### Helper Functions\n#### assign\n`crocks/helpers/assign`\n```haskell\nassign :: Object -> Object -> Object\n```\nWhen working with `Object`s, a common operation is to combine (2) of them. This\ncan be accomplished in `crocks` by reaching for `assign`. Unlike the\n`Object.assign` that ships with JavaScript, this `assign` will combine your\n`Object`s into a new shallow copy of their merger. `assign` only takes two\narguments and will overwrite keys present in the second argument with values\nfrom the first. As with most of the `crocks` `Object` based functions, `assign`\nwill omit any key-value pairs that are `undefined`. Check out a related function\nnamed [`defaultProps`](#defaultprops) that will only assign values that are\n`undefined` in the second argument.\n\n#### assoc\n`crocks/helpers/assoc`\n```haskell\nassoc :: String -> a -> Object -> Object\n```\nThere may come a time when you want to add a key-value pair to an `Object` and\nwant control over how the key and value are applied. That is where `assoc` can\ncome to your aid. Just provide a `String` key and a value of any type to be\nassociated to the key. Finally pass it any `Object` and you will get back a\nshallow copy with your key-value pair merged in. This will overwrite any exiting\nkeys with new value specified. Used with [`flip`](#flip), you can do some\ninteresting things with this function, give it a play! If you just want to\ncreate an `Object` and not concatenate it to another `Object`, [`objOf`](#objof)\nmay be the function for you.\n\n#### binary\n`crocks/helpers/binary`\n```haskell\nbinary :: (* -> c) -> a -> b -> c\n```\nWith all the different functions out there in the real world, sometimes it is\nnice to restrict them to a specific -arity to work with your all your wonderful\ncompositions. When you want to restict any function of any arity to a simple\nbinary function. Just pass your function to `binary` and you will get back a\ncurried, binary function that will only apply (2) arguments to the inner\nfunction, ignoring any others. This works very well with functions like\n`Array.prototype.reduce` where you may only care about the first 2 arguments.\nif you need to constrain to more than (2) arguments, then you will want to reach\nfor  [`nAry`](#nary). `binary` is basically syntactic sugar for `nAry(2, fn)`.\nAlso related is [`unary`](#unary), which constrains to (1) argument.\n\n#### branch\n`crocks/Pair/branch`\n```haskell\nbranch :: a -> Pair a a\n```\nWhen you want to branch a computation into two parts, this is the function you\nwant to reach for. All it does is let you pass in any `a` and will return you a\n`Pair` that has your value on both the first and second parameter. This allows\nyou to work on the value in two separate computation paths. Be advised that this\nis Javascript and if `a` is an object type (`Object`, `Array`, `Date`, etc) they\nwill reference each other.\n\n**Pro-Tip**: `Pair` provides a `merge` function that will let you fold the two\nvalues into a single value.\n\n#### compose\n`crocks/helpers/compose`\n```haskell\ncompose :: ((y -> z), (x -> y), ..., (a -> b)) -> a -> z\n```\nWhile the [`composeB`](#composeb) can be used to create a composition of two\nfunctions, there are times when you want to compose an entire flow together.\nThat is where `compose` is useful. With `compose` you can create a right-to-left\ncomposition of functions. It will return you a function that represents your\nflow. Not really sold on writing flows from right-to-left? Well then, I would\nrecommend reaching for [`pipe`](#pipe).\n\n#### composeK\n`crocks/helpers/composeK`\n```haskell\ncomposeK :: Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> a -> m z\n```\nThere are many times that, when working with the various `crocks`, our flows are\njust a series of `chain`s. Due to some neat properties with types that provide a\n`chain` function, you can remove some boilerplate by reaching for `composeK`.\nJust pass it the functions you would normally pass to `chain` and it will do all\nthe boring hook up for you. Just like `compose`, functions are applied\nright-to-left, so you can turn this:\n\n```js\nconst { chain, compose, isObject, prop, safe } = crocks\n\nconst data = {\n  do: { re: { mi: 'fa' } }\n}\n\n// fluent :: a -> Maybe b\nconst fluent = x =>\n  safe(isObject, x)\n    .chain(prop('do'))\n    .chain(prop('re'))\n    .chain(prop('mi'))\n\nfluent(data)\n// => Just 'fa'\n\n// pointfree :: a -> Maybe b\nconst pointfree = compose(\n  chain(prop('mi')),\n  chain(prop('re')),\n  chain(prop('do')),\n  safe(isObject)\n)\n\npointfree(data)\n// => Just 'fa'\n```\n\ninto the more abbreviated form:\n\n```js\nconst { composeK, isObject, prop, safe } = crocks\n\nconst data = {\n  do: { re: { mi: 'fa' } }\n}\n\n// flow :: a -> Maybe b\nconst flow = composeK(\n  prop('mi'),\n  prop('re'),\n  prop('do'),\n  safe(isObject)\n)\n\nflow(data)\n// => Just 'fa'\n```\nAs demonstrated in the above example, this function more closely resembles flows\nthat are using a more pointfree style of coding. As with the other composition\nfunctions in `crocks`, a [`pipeK`](#pipek) function is provided for flows that\nmake more sense expressed in a left-to-right style.\n\n#### composeP\n`crocks/helpers/composeP`\n```haskell\ncomposeP :: Promise p => ((y -> p z c), (x -> p y c), ..., (a -> p b c)) -> a -> p z c\n```\nWhen working with `Promise`s, it is common place to create chains on a\n`Promise`'s `then` function:\n```js\nconst promFunc = x =>\n  promiseSomething(x)\n    .then(doSomething)\n    .then(doAnother)\n```\n\nDoing this involves a lot of boilerplate and forces you into a fluent style,\nwhether you want to be or not. Using `composeP` you have the option to compose a\nseries of `Promise` returning functions like you would any other function\ncomposition, in a right-to-left fashion. Like so:\n\n```js\nconst { composeP } = crocks\n\nconst promFunc =\n  composeP(doAnother, doSomething, promiseSomething)\n```\nDue to the nature of the `then` function, only the head of your composition\nneeds to return a `Promise`. This will create a function that takes a value,\nwhich is passed through your chain, returning a `Promise` which can be extended.\nThis is only a `then` chain, it does not do anything with the `catch` function.\nIf you would like to provide your functions in a left-to-right manner, check out\n[pipeP](#pipep).\n\n#### composeS\n`crocks/helpers/composeS`\n```haskell\ncomposeS :: Semigroupoid s => (s y z, s x y, ..., s a b) -> s a z\n```\nWhen working with things like `Arrow` and `Star` there will come a point when\nyou would like to compose them like you would any `Function`. That is where\n`composeS` comes in handy. Just pass it the `Semigroupoid`s you want to compose\nand it will give you back a new `Semigroupoid` of the same type with all of the\nunderlying functions composed and ready to be run. Like [`compose`](#compose),\n`composeS` composes the functions in a right-to-left fashion. If you would like\nto represent your flow in a more left-to-right manner, then [`pipeS`](#pipes) is\nprovided for such things.\n\n```js\nconst {\n  Arrow, bimap, branch, composeS, merge, mreduce, Sum\n} = require('crocks')\n\nconst length =\n  xs => xs.length\n\nconst divide =\n  (x, y) => x / y\n\nconst avg =\n  Arrow(bimap(mreduce(Sum), length))\n    .promap(branch, merge(divide))\n\nconst double =\n  Arrow(x => x * 2)\n\nconst data =\n  [ 34, 198, 3, 43, 92 ]\n\ncomposeS(double, avg)\n  .runWith(data)\n// => 148\n```\n\n#### curry\n`crocks/helpers/curry`\n```haskell\ncurry :: ((a, b, ...) -> z) -> a -> b -> ... -> z\n```\nPass this function a function and it will return you a function that can be\ncalled in any form that you require until all arguments have been provided. For\nexample if you pass a function: `f : (a, b, c) -> d` you get back a function\nthat can be called in any combination, such as: `f(x, y, z)`, `f(x)(y)(z)`,\n`f(x, y)(z)`, or even `f(x)(y, z)`. This is great for doing partial application\non functions for maximum re-usability.\n\n#### defaultProps\n`crocks/helpers/defaultProps`\n```haskell\ndefaultProps :: Object -> Object -> Object\n```\nPicture this, you have an `Object` and you want to make sure that some\nproperties are set with a given default value. When the need for this type of\noperation presents itself, `defaultProps` can come to your aid. Just pass it an\n`Object` that defines your defaults and then the `Object` your want to default\nthose props on. If a key that is present on the defaults `Object` is not defined\non your data, then the default value will be used. Otherwise, the value from\nyour data will be used instead. You could just apply [`flip`](#flip) to the\n[`assign`](#assign) function and get the same result, but having a function\nnamed `defaultProps` may be easier to read in code. As with most `Object`\nrelated functions in `crocks`, `defaultProps` will return you a shallow copy of\nthe result and not include any `undefined` values in either `Object`.\n\n#### defaultTo\n`crocks/helpers/defaultTo`\n```haskell\ndefaultTo :: a -> b -> a\n```\nWith things like `null`, `undefined` and `NaN` showing up all over the place, it\ncan be hard to keep your expected types inline without resorting to nesting in a\n`Maybe` with functions like [`safe`](#safe). If you want to specifically guard\nfor `null`, `undefined` and `NaN` and get things defaulted into the expected\ntype, then `defaultTo` should work for you. Just pass it what you would like\nyour default value to be and then the value you want guarded, and you will get\nback either the default or the passed value, depending on if the passed value is\n`null`, `undefined` or `NaN`. While this *is* JavaScript and you can return\nanything, it is suggested to stick to the signature and only let `a`s through.\nAs a `b` can be an `a` as well.\n\n#### dissoc\n`crocks/helpers/dissoc`\n```haskell\ndissoc :: String -> Object -> Object\n```\nWhile [`assoc`](#assoc) can be used to associate a given key-value pair to a\ngiven `Object`, `dissoc` does the opposite. Just pass `dissoc` a `String` key\nand the `Object` you wish to dissociate that key from and you will get back a\nnew, shallow copy of the `Object` sans your key. As with all the `Object`\nfunctions, `dissoc` will remove any `undefined` values from the result.\n\n#### fanout\n`crocks/helpers/fanout`\n```haskell\nfanout :: (a -> b) -> (a -> c) -> (a -> Pair b c)\nfanout :: Arrow a b -> Arrow a c -> Arrow a (Pair b c)\nfanout :: Monad m => Star a (m b) -> Star a (m c) -> Star a (m (Pair b c))\n```\nThere are may times that you need to keep some running or persistent state while\nperforming a given computation. A common way to do this is to take the input to\nthe computation and branch it into a `Pair` and perform different operations on\neach version of the input. This is such a common pattern that it warrants the\n`fanout` function to take care of the initial split and mapping. Just provide a\npair of either simple functions or a pair of one of the computation types\n(`Arrow` or `Star`). You will get back something of the same type that is\nconfigured to split it's input into a pair and than apply the first Function/ADT\nto the first portion of the underlying `Pair` and the second on the second.\n\n#### fromPairs\n`crocks/helpers/fromPairs`\n```haskell\nfromPairs :: [ (Pair String a) ] | List (Pair String a) -> Object\n```\nAs an inverse to [`toPairs`](#topairs), `fromPairs` takes either an `Array` or\n`List` of key-value `Pair`s and constructs an `Object` from it. The `Pair` must\ncontain a `String` in the `fst` and any type of value in the `snd`. The `fst`\nwill become the key for the value in the `snd`. All primitive values are copied\ninto the new `Object`, while non-primitives are references to the original. If\nyou provide an `undefined` values for the second, that `Pair` will not be\nrepresented in the resulting `Object`. Also, when if multiple keys share the\nsame name, that last value will be moved over.\n\n#### liftA2\n#### liftA3\n`crocks/helpers/liftA2`\n`crocks/helpers/liftA3`\n```haskell\nliftA2 :: Applicative m => (a -> b -> c) -> m a -> m b -> m c\nliftA3 :: Applicative m => (a -> b -> c -> d) -> m a -> m b -> m c -> m d\n```\nEver see yourself wanting to `map` a binary or trinary function, but `map` only\nallows unary functions? Both of these functions allow you to pass in your\nfunction as well as the number of `Applicatives` (containers that provide both\n`of` and `ap` functions) you need to get the mapping you are looking for.\n\n#### mapProps\n`crocks/helpers/mapProps`\n```haskell\nmapProps :: { (* -> *) } -> Object -> Object\n```\nWould like to map specific keys in an Object with a specific function? Just\nbring in `mapProps` and pass it an `Object` with the functions you want to apply\non the keys you want them associated to. When the resulting function receives an\n`Object`, it will return a new `Object` with the keys mapped according to the\nmapping functions. All keys from the original `Object` that do not exist in\nthe mapping `Object` will still exist untouched, but the keys with mapping\nfunctions with now contain the result of applying the original value to the\nprovided mapping function.\n\n`mapProps` also allows for mapping on nested `Object`s for times when the shape\nof the original `Object` is know.\n\n```javascript\nconst mapProps = require('crocks/helpers/mapProps')\n\nconst add =\n  x => y => x + y\n\nconst toUpper =\n  x => x.toUpperCase()\n\nconst mapping = {\n  entry: toUpper,\n  fauna: {\n    unicorns: add(1),\n    elephants: add(-1)\n  },\n  flora: {\n    nariphon: add(10),\n    birch: add(1)\n  }\n}\n\nmapProps(mapping, {\n  entry: 'legend',\n  fauna: {\n    unicorns: 10,\n    zombies: 3\n  },\n  other: {\n    hat: 2\n  }\n})\n\n//=> { entry: 'LEGEND', fauna: { unicorns: 11, zombies: 3 }, other: { hat: 2} }\n```\n\n#### mapReduce\n`crocks/helpers/mapReduce`\n```haskell\nmapReduce :: Foldable f => (a -> b) -> (c -> b -> c) -> c -> f a\n```\nSometimes you need the power provided by [`mreduceMap`](#mreducemap) but you do\nnot have a `Monoid` to lift into. `mapReduce` provides the same power, but with\nthe flexibility of using functions to lift and combine. `mapReduce` takes a\nunary mapping function, a binary reduction function, the initial value and\nfinally a `Foldable` structure of data. Once all arguments are provided,\n`mapReduce` folds the provided data, by mapping each value through your mapping\nfunction, before sending it to the second argument of your reduction function.\n\n```javascript\nconst  Max = require('crocks/Max')\nconst { Nothing } = require('crocks/Maybe')\nconst  isNumber = require('crocks/predicates/isNumber')\nconst  mapReduce = require('crocks/helpers/mapReduce')\nconst  safeLift = require('crocks/Maybe/safeLift')\n\n\nconst data =\n  [ '100', null, 3, true, 1 ]\n\nconst safeMax = mapReduce(\n  safeLift(isNumber, Max),\n  (y, x) => y.concat(x).alt(y).alt(x),\n  Nothing()\n)\n\nsafeMax(data)\n  .option(Max.empty())\n  .valueOf()\n// => 3\n```\n\n#### mconcat\n#### mreduce\n`crocks/helpers/mconcat`\n`crocks/helpers/mreduce`\n```haskell\nmconcat :: Monoid m => m -> ([ a ] | List a) -> m a\nmreduce :: Monoid m => m -> ([ a ] | List a) -> a\n```\nThese two functions are very handy for combining an entire `List` or `Array` of\nvalues by providing a [`Monoid`](#monoids) and your collection of values. The\ndifference between the two is that `mconcat` returns the result inside the\n[`Monoid`](#monoids) used to combine them. Where `mreduce` returns the bare\nvalue itself.\n\n#### mconcatMap\n#### mreduceMap\n`crocks/helpers/mconcatMap`\n`crocks/helpers/mreduceMap`\n```haskell\nmconcatMap :: Monoid m => m -> (b -> a) -> ([ b ] | List b) -> m a\nmreduceMap :: Monoid m => m -> (b -> a) -> ([ b ] | List b) -> a\n```\nThere comes a time where the values you have in a `List` or an `Array` are not\nin the type that is needed for the [`Monoid`](#monoids) you want to combine\nwith. These two functions can be used to `map` some transforming function from a\ngiven type into the type needed for the [`Monoid`](#monoids). In essence, this\nfunction will run each value through the function before it lifts the value\ninto the [`Monoid`](#monoids), before `concat` is applied. The difference\nbetween the two is that `mconcatMap` returns the result inside the\n[`Monoid`](#monoids) used to combine them. Where `mreduceMap` returns the bare\nvalue itself.\n\n#### nAry\n`crocks/helpers/nAry`\n```haskell\nnAry :: Number -> (* -> a) -> * -> * -> a\n```\nWhen using functions like `Math.max` or `Object.assign` that take as many\narguments as you can throw at them, it makes it hard to `curry` them in a\nreasonable manner. `nAry` can make things a little nicer for functions like\nthat. It can also be put to good use to limit a given function to a desired\nnumber of arguments to avoid accidentally supplying default arguments when you\ndo not what them applied. First pass `nAry` the number of arguments you wish to\nlimit the function to and then the function you wish to limit. `nAry` will give\nyou back a curried function that will only apply the specified number of\narguments to the inner function. Unary and binary functions are so common that\n`crocks` provides specific functions for those cases: [`unary`](#unary) and\n[`binary`](#binary).\n\n#### objOf\n`crocks/helpers/objOf`\n```haskell\nobjOf :: String -> a -> Object\n```\nIf you ever find yourself in a situation where you have a key and a value and\njust want to combine the two into an `Object`, then it sounds like `objOf` is\nthe function for you. Just pass it a `String` for the key and any type of value,\nand you'll get back an `Object` that is composed of those two. If you find\nyourself constantly concatenating the result of this function into another\n`Object`, you may want to use [`assoc`](#assoc) instead.\n\n#### omit\n`crocks/helpers/omit`\n```haskell\nomit :: ([ String ] | List String) -> Object -> Object\n```\nSometimes you just want to strip `Object`s of unwanted properties by key. Using\n`omit` will help you get that done. Just pass it a `Foldable` structure with a\nseries of `String`s as keys and then pass it an `Object` and you will get back\nnot only a shallow copy, but also an `Object` free of any of those pesky\n`undefined` values. You can think of `omit` as a way to black-list or reject\n`Object` properties based on key names. This function ignores inherited\nproperties and should only be used with POJOs. If you want to filter or\nwhite-list properties rather than reject them, take a look at [`pick`](#pick).\n\n#### once\n`crocks/helpers/once`\n```haskell\nonce :: ((*) -> a) -> ((*) -> a)\n```\nThere are times in Javascript development where you only want to call a function\nonce and memo-ize the first result for every subsequent call to that function.\nJust pass the function you want guarded to `once` and you will get back a\nfunction with the expected guarantees.\n\n#### partial\n`crocks/helpers/partial`\n```haskell\npartial :: ((* -> c), *) -> * -> c\n```\nThere are many times when using functions from non-functional libraries or from\nbuilt-in JS functions, where it does not make sense to wrap it in a\n[`curry`](#curry). You just want to partially apply some arguments to it and get\nback a function ready to take the rest. That is a perfect opportunity to use\n`partial`. Just pass a function as the first argument and then apply any other\narguments to it. You will get back a curried function that is ready to accept\nthe rest of the arguments.\n\n```js\nconst { map, partial } = require('crocks')\n\nconst max10 =\n  partial(Math.min, 10)\n\nconst data =\n  [ 13, 5, 13 ]\n\nmap(max10, data)\n// => [ 10, 5, 10]\n```\n\n#### pick\n`crocks/helpers/pick`\n```haskell\npick :: ([ String ] | List String) -> Object -> Object\n```\nWhen dealing with `Object`s, sometimes it is necessary to only let some of the\nkey-value pairs on an object through. Think of `pick` as a sort of white-list or\nfilter for `Object` properties. Pass it a `Foldable` structure of `String`s that\nare the keys you would like to pick off of your `Object`. This will give you\nback a shallow copy of the key-value pairs you specified. This function will\nignore inherited properties and should only be used with POJOs. Any `undefined`\nvalues will not be copied over, although `null` values are allowed. For\nblack-listing properties, have a look at [`omit`](#omit).\n\n#### pipe\n`crocks/helpers/pipe`\n```haskell\npipe :: ((a -> b), (b -> c), ..., (y -> z)) -> a -> z\n```\nIf you find yourself not able to come to terms with doing the typical\nright-to-left composition, then `crocks` provides a means to accommodate you.\nThis function does the same thing as [`compose`](#compose), the only difference\nis it allows you define your flows in a left-to-right manner.\n\n#### pipeK\n`crocks/helpers/pipeK`\n```haskell\npipeK :: Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> a -> m z\n```\nLike [`composeK`](#composek), you can remove much of the boilerplate when\nchaining together a series of functions with the signature:\n`Chain m => a -> m b`. The difference between the two functions is, while\n[`composeK`](#composek) is right-to-left, `pipeK` is the opposite, taking its\nfunctions left-to-right.\n\n```js\nconst { curry, List, Writer } = require('../crocks')\n\nconst OpWriter =\n  Writer(List)\n\nconst addLog = curry(\n  (x, y) => OpWriter(`adding ${x} to ${y}`, x + y)\n)\n\nconst scaleLog = curry(\n  (x, y) => OpWriter(`scaling ${y} by ${x}`, x * y)\n)\n\nconst fluent = x =>\n  OpWriter.of(x)\n    .chain(addLog(4))\n    .chain(scaleLog(3))\n\nfluent(0).log()\n// => List [ \"adding 4 to 0\", \"scaling 4 by 3\" ]\n\nconst chainPipe = pipeK(\n  addLog(4),\n  scaleLog(3)\n)\n\nchainPipe(0).log()\n// => List [ \"adding 4 to 0\", \"scaling 4 by 3\" ]\n```\n\n#### pipeP\n`crocks/helpers/pipeP`\n```haskell\npipeP :: Promise p => ((a -> p b d), (b -> p c d), ..., (y -> p z d)) -> a -> p z d\n```\nLike the [`composeP`](#composep) function, `pipeP` will let you remove the\nstandard boilerplate that comes with working with `Promise` chains. The only\ndifference between `pipeP` and [`composeP`](#composep) is that it takes its\nfunctions in a left-to-right order:\n\n```js\nconst { pipeP } = crocks\n\nconst promFunc = x =>\n  promise(x)\n    .then(doSomething)\n    .then(doAnother)\n\nconst promPipe =\n  pipeP(proimse, doSomething, doAnother)\n```\n\n#### pipeS\n`crocks/helpers/pipeS`\n```haskell\npipeS :: Semigroupoid s => (s a b, s b c, ..., s y z) -> s a z\n```\nWhile `Star`s and `Arrow`s come in very handy at times, the only thing that\ncould make them better is to compose them . With `pipeS` you can do just that\nwith any `Semigroupoid`. Just like with [`composeS`](#composes), you just pass\nit `Semigroupoid`s of the same type and you will get back another `Semigroupoid`\nwith them all composed together. The only difference between the two, is that\n`pipeS` composes in a left-to-right fashion, while [`composeS`](#composes) does\nthe opposite.\n\n```js\nconst {\n  curry, isNumber, pipeS, prop, safeLift, Star\n} = require('../crocks')\n\nconst add = curry(\n  (x, y) => x + y\n)\n\nconst pull =\n  x => Star(prop(x))\n\nconst safeAdd =\n  x => Star(safeLift(isNumber, add(x)))\n\nconst data = {\n  num: 56,\n  string: '56'\n}\n\nconst flow = (key, num) => pipeS(\n  pull(key),\n  safeAdd(num)\n)\n\nflow('num', 10).runWith(data)\n// => Just 66\n\nflow('string', 100).runWith(data)\n// => Nothing\n```\n\n#### prop\n`crocks/Maybe/prop`\n```haskell\nprop :: (String | Number) -> a -> Maybe b\n```\nIf you want some safety around pulling a value out of an Object or Array with a\nsingle key or index, you can always reach for `prop`. Well, as long as you are\nworking with non-nested data that is. Just tell `prop` either the key or index\nyou are interested in, and you will get back a function that will take anything\nand return a `Just` with the wrapped value if the key/index exists. If the\nkey/index does not exist however, you will get back a `Nothing`.\n\n#### propPath\n`crocks/Maybe/propPath`\n```haskell\npropPath :: [ String | Number ] -> a -> Maybe b\n```\nWhile [`prop`](#prop) is good for simple, single-level structures, there may\ncome a time when you have to work with nested POJOs or Arrays. When you run into\nthis situation, just pull in `propPath` and pass it a left-to-right traversal\npath of keys, indices or a combination of both (gross...but possible). This will\nkick you back a function that behaves just like [`prop`](#prop). You pass it\nsome data, and it will attempt to resolve your provided path. If the path is\nvalid, it will return the value residing there (`null` included!) in a `Just`.\nBut if at any point that path \"breaks\" it will give you back a `Nothing`.\n\n#### safe\n`crocks/Maybe/safe`\n```haskell\nsafe :: ((a -> Boolean) | Pred) -> a -> Maybe a\n```\nWhen using a `Maybe`, it is a common practice to lift into a `Just` or a\n`Nothing` depending on a condition on the value to be lifted.  It is so common\nthat it warrants a function, and that function is called `safe`. Provide a\npredicate (a function that returns a Boolean) and a value to be lifted. The\nvalue will be evaluated against the predicate, and will lift it into a `Just` if\ntrue and a `Nothing` if false.\n\n#### safeLift\n`crocks/Maybe/safeLift`\n```haskell\nsafeLift :: ((a -> Boolean) | Pred) -> (a -> b) -> a -> Maybe b\n```\nWhile [`safe`](#safe) is used to lift a value into a `Maybe`, you can reach for\n`safeLift` when you want to run a function in the safety of the `Maybe` context.\nJust like [`safe`](#safe), you pass it either a `Pred` or a predicate function\nto determine if you get a `Just` or a `Nothing`, but then instead of a value,\nyou pass it a unary function. `safeLift` will then give you back a new function\nthat will first lift its argument into a `Maybe` and then maps your original\nfunction over the result.\n\n#### tap\n`crocks/helpers/tap`\n```haskell\ntap :: (a -> b) -> a -> a\n```\nIt is hard knowing what is going on inside of some of these ADTs or your\nwonderful function compositions. Debugging can get messy when you need to insert\na side-effect into your flow for introspection purposes. With `tap`, you can\nintervene in your otherwise pristine flow and make sure that the original value\nis passed along to the next step of your flow. This function does not guarantee\nimmutability for reference types (`Objects`, `Arrays`, etc), you will need to\nexercise some discipline here to not mutate.\n\n#### toPairs\n`crocks/Pair/toPairs`\n```haskell\ntoPairs :: Object -> List (Pair String a)\n```\nWhen dealing with `Object`s, sometimes it makes more sense to work in a\n`Foldable` structure like a `List` of key-value `Pair`s. `toPairs` provides a\nmeans to take an object and give you back a `List` of `Pairs` that have a\n`String` that represents the key in the `fst` and the value for that key in the\n`snd`. The primitive values are copied, while non-primitive values are\nreferences. Like most of the `Object` functions in `crocks`, any keys with\n`undefined` values will be omitted from the result. `crocks` provides an inverse\nto this function named [`fromPairs`](#frompairs).\n\n#### tryCatch\n`crocks/Result/tryCatch`\n```haskell\ntryCatch :: (a -> b) -> a -> Result e b\n```\nTypical try-catch blocks are very imperative in their usage. This `tryCatch`\nfunction provides a means of capturing that imperative nature in a simple\ndeclarative style. Pass it a function that could fail and it will return you\nanother function wrapping the first function. When called, the new function will\neither return the result in a `Result.Ok` if everything was good, or an error\nwrapped in an `Result.Err` if it fails.\n\n#### unary\n`crocks/helpers/unary`\n```haskell\nunary :: (* -> b) -> a -> b\n```\nIf you every need to lock down a given function to just one argument, then look\nno further than `unary`. Just pass it a function of any arity, and you will get\nback another function that will only apply (1) argument to given function, no\nmatter what is passed to it. `unary` is just syntactic sugar around\n[`nAry`](#nary) in the form of `nAry(1, fn)` as it is such a common case.\nAnother common case is [`binary`](#binary) which, as the name implies, only\napplies (2) arguments to a given function.\n\n#### unit\n`crocks/helpers/unit`\n```haskell\nunit :: () -> undefined\n```\nWhile it seems like just a simple function, `unit` can be used for a number of\nthings. A common use for it is as a default `noop` as it is a function that does\nnothing and returns `undefined`. You can also use it in a pointed fashion to\nrepresent some special value for a given type. This pointed use is the heart and\nsoul of the infamous `Maybe` type.\n\n### Logic Functions\nThe functions in this section are used to represent logical branching in a\ndeclarative manner. Each of these functions require either `Pred`s or predicate\nfunctions in their input. Since these functions work with `Pred`s and predicate\nfunctions, rather than values, this allows for composeable, \"lazy\" evaluation.\nAll logic functions can be referenced from `crocks/logic`\n\n#### and\n```haskell\nand :: ((a -> Boolean) | Pred) -> ((a -> Boolean) | Pred) -> a -> Boolean\n```\nSay you have two predicate functions or `Pred`s and would like to combine them\ninto one predicate over conjunction, well you came to the right place, `and`\naccepts either predicate functions or `Pred`s and will return you a function\nready to take a value. Once that value is passed, it will run it through both of\nthe predicates and return the result of combining it over a `logical and`. This\nis super helpful combined with `or` for putting together reusable, complex\npredicates. As they follow the general form of `(a -> Boolean)` they are easily\ncombined with other logic functions.\n\n#### ifElse\n```haskell\nifElse :: ((a -> Boolean) | Pred) -> (* -> a) -> (* -> a) -> * -> a\n```\nWhenever you need to modify a value based some condition and want a functional\nway to do it without some imperative `if` statement, then reach for `ifElse`.\nThis function take a predicate (some function that returns a Boolean) and two\nfunctions. The first is what is executed when the predicate is true, the second\non a false condition. This will return a function ready to take a value to run\nthrough the predicate. After the value is evaluated, it will be ran through it's\ncorresponding function, returning the result as the final result. This function\ncomes in really handy when creating lifting functions for Sum Types (like\n`Either` or `Maybe`).\n\n#### not\n```haskell\nnot :: ((a -> Boolean) | Pred) -> a -> Boolean\n```\nWhen you need to negate a predicate function or a `Pred`, but want a new\npredicate function that does the negation, then `not` is going to get you what\nyou need. Using `not` will allow you to stay as declarative as possible. Just\npass `not` your predicate function or a `Pred`, and it will give you back a\npredicate function ready for insertion into your flow. All predicate based\nfunctions in `crocks` take either a `Pred` or predicate function, so it should\nbe easy to swap between the two.\n\n#### or\n```haskell\nor :: ((a -> Boolean) | Pred) -> ((a -> Boolean) | Pred) -> a -> Boolean\n```\nSay you have two predicate functions or `Pred`s and would like to combine them\ninto one predicate over disjunction, look no further, `or` accepts either\npredicate functions or `Pred`s and will return you a function ready to take a\nvalue. Once that value is passed, it will run it through both of the predicates\nand return the result of combining it over a `logical or`. This is super helpful\ncombined with `and` for putting together reusable, complex predicates. As they\nfollow the general form of `(a -> Boolean)` they are easily combined with other\nlogic functions.\n\n#### unless\n```haskell\nunless :: ((a -> Boolean) | Pred) -> (a -> a) -> a -> a\n```\nThere may come a time when you need to adjust a value when a condition is false,\nthat is where `unless` can come into play. Just provide a predicate function (a\nfunction that returns a Boolean) and a function to apply your desired\nmodification. This will get you back a function that when you pass it a value,\nit will evaluate it and if false, will run your value through the provided\nfunction. Either the original or modified value will be returned depending on\nthe result of the predicate. Check out [`when`](#when) for a negated version of\nthis function.\n\n#### when\n```haskell\nwhen :: ((a -> Boolean) | Pred) -> (a -> a) -> a -> a\n```\nThere may come a time when you need to adjust a value when a condition is true,\nthat is where `when` can come into play. Just provide a predicate function (a\nfunction that returns a Boolean) and a function to apply your desired\nmodification. This will get you back a function that when you pass it a value,\nit will evaluate it and if true, will run your value through the provided\nfunction. Either the original or modified value will be returned depending on\nthe result of the predicate. Check out [`unless`](#unless) for a negated version\nof this function.\n\n### Predicate Functions\nAll functions in this group have a signature of `* -> Boolean` and are used with\nthe many predicate based functions that ship with `crocks`, like\n[`safe`](#safe), [`ifElse`](#ifelse) and `filter` to name a few. They also fit\nnaturally with the `Pred` ADT. All predicate functions can be referenced from\n`crocks/predicates` Below is a list of all the current predicates that are\nincluded with a description of their truth:\n\n* `hasProp :: (String | Number) -> a -> Boolean`: An Array or Object that contains the provided index or key\n* `isAlt :: a -> Boolean`: an ADT that provides `map` and `alt` functions\n* `isAlternative :: a -> Boolean`: an ADT that provides `alt`, `zero`, `map`, `ap`, `chain` and `of` functions\n* `isApplicative :: a -> Boolean`: an ADT that provides `map`, `ap` and `of` functions\n* `isApply :: a -> Boolean`: an ADT that provides `map` and `ap` functions\n* `isArray :: a -> Boolean`: Array\n* `isBifunctor :: a -> Boolean`: an ADT that provides `map` and `bimap` functions\n* `isBoolean :: a -> Boolean`: Boolean\n* `isCategory :: a -> Boolean`: an ADT that provides `id` and `compose` functions\n* `isChain :: a -> Boolean`: an ADT that provides `map`, `ap` and `chain` functions\n* `isContravariant : a -> Boolean`: an ADT that provides `contramap` function\n* `isDefined :: a -> Boolean`: Every value that is not `undefined`, `null` included\n* `isEmpty :: a -> Boolean`: Empty Object, Array or String\n* `isExtend :: a -> Boolean`: an ADT that provides `map` and `extend` functions\n* `isFoldable :: a -> Boolean`: Array, List or any structure with a `reduce` function\n* `isFunction :: a -> Boolean`: Function\n* `isFunctor :: a -> Boolean`: an ADT that provides a `map` function\n* `isInteger :: a -> Boolean`: Integer\n* `isMonad :: a -> Boolean`: an ADT that provides `map`, `ap`, `chain` and `of` functions\n* `isMonoid :: a -> Boolean`: an ADT that provides `concat` and `empty` functions\n* `isNil :: a -> Boolean`: `undefined` or `null` or `NaN`\n* `isNumber :: a -> Boolean`: `Number` that is not a `NaN` value, `Infinity` included\n* `isObject :: a -> Boolean`: Plain Old Javascript Object (POJO)\n* `isPlus :: a -> Boolean`: an ADT that provides `map`, `alt` and `zero` functions\n* `isProfunctor : a -> Boolean`: an ADT that provides `map`, `contramap` and `promap` functions\n* `isPromise :: a -> Boolean`: an object implementing `then` and `catch`\n* `isSame :: a -> b -> Boolean`: same value or reference, use `equals` for value equality\n* `isSameType :: a -> b -> Boolean`: Constructor matches a values type, or two values types match\n* `isSemigroup :: a -> Boolean`: an ADT that provides a `concat` function\n* `isSemigroupoid :: a -> Boolean`: an ADT that provides a `compose` function\n* `isSetoid :: a -> Boolean`: an ADT that provides an `equals` function\n* `isString :: a -> Boolean`: String\n* `isTraversable :: a -> Boolean`: an ADT that provides `map` and `traverse` functions\n\n### Point-free Functions\nWhile it can seem natural to work with all these containers in a fluent fashion,\nit can get cumbersome and hard to get a lot of reuse out of. A way to really get\nthe most out of reusability in Javascript is to take what is called a point-free\napproach. Below is a small code same to contrast the difference between the two\ncalling styles:\n\n```javascript\nconst crocks = require('crocks')\n\nconst {\n  compose, map, safe, isInteger\n} = crocks // map is the point-free function\n\n// isEven :: Integer -> Boolean\nconst isEven =\n  x => (x % 2) === 0\n\n// maybeInt :: a -> Maybe Integer\nconst maybeInt =\n  safe(isInteger)\n\n// fluentIsEven :: a -> Maybe Boolean\nconst fluentIsEven = data =>\n  maybeInt(data)\n    .map(isEven)\n\n// pointfreeIsEven :: a -> Maybe Boolean\nconst pointfreeIsEven =\n  compose(map(isEven), maybeInt)\n```\n\nThese functions provide a very clean way to build out very simple functions and\ncompose them all together to compose a more complicated flow. Each point-free\nfunction provided in `crocks` is \"auto-curried\" and follows a \"data-last\"\npattern in the order of how it receives it's arguments. Typically the most\nstable of the arguments comes first, moving all the way to the least stable\nargument (which usually is the data flowing through your composition). Below\nlists the provided functions and the data types they work with (`m` refers to an\naccepted Datatype):\n\n##### Signatures\n| Function | Signature | Location |\n|---|:---|:---|\n| `alt` | `m a -> m a -> m a` | `crocks/pointfree` |\n| `ap` | `m a -> m (a -> b) -> m b` | `crocks/pointfree` |\n| `bimap` | `(a -> c) -> (b -> d) -> m a b -> m c d` | `crocks/pointfree` |\n| `both` | `m (a -> b) -> m (Pair a a -> Pair b b)` | `crocks/pointfree` |\n| `chain` | `(a -> m b) -> m a -> m b` | `crocks/pointfree` |\n| `coalesce` | `(a -> c) -> (b -> c) -> m a b -> m _ c` | `crocks/pointfree` |\n| `concat` | `m a -> m a -> m a` | `crocks/pointfree` |\n| `cons` | `a -> m a -> m a` | `crocks/pointfree` |\n| `contramap` | `(b -> a) -> m a -> m b` | `crocks/pointfree` |\n| `either` | `(a -> c) -> (b -> c) -> m a b -> c` | `crocks/pointfree` |\n| `empty` | `m -> m` | `crocks/pointfree` |\n| `equals` | `m -> m -> Boolean` | `crocks/pointfree` |\n| `evalWith` | `a -> m -> b` | `crocks/State` |\n| `execWith` | `a -> m -> b` | `crocks/State` |\n| `extend` | `(m a -> b) -> m a -> m b` | `crocks/pointfree` |\n| `filter` | <code>((a -> Boolean) &#124; Pred a) -> m a -> m a</code> | `crocks/pointfree` |\n| `first` | `m (a -> b) -> m (Pair a c -> Pair b c)` | `crocks/pointfree` |\n| `fold` | `Semigroup s => m s -> s` | `crocks/pointfree` |\n| `fst` | `m a b -> a` | `crocks/Pair` |\n| `head` | `m a -> Maybe a` | `crocks/pointfree` |\n| `log` | `m a b -> a` | `crocks/Writer` |\n| `map` | `(a -> b) -> m a -> m b` | `crocks/pointfree` |\n| `merge` | `(a -> b -> c) -> m a b -> c` | `crocks/Pair` |\n| `option` | `a -> m a -> a` | `crocks/pointfree` |\n| `promap` | `(c -> a) -> (b -> d) -> m a b -> m c d` | `crocks/pointfree` |\n| `read` | `m a b -> Pair a b` | `crocks/Writer` |\n| `reduce` | `(b -> a -> b) -> b -> m a -> b` | `crocks/pointfree` |\n| `reject` | <code>((a -> Boolean) &#124; Pred a) -> m a -> m a</code> | `crocks/pointfree` |\n| `run` | `m a -> b` | `crocks/pointfree` |\n| `runWith` | `a -> m -> b` | `crocks/pointfree` |\n| `second` | `m (a -> b) -> m (Pair c a -> Pair c b)` | `crocks/pointfree` |\n| `sequence` | `Applicative f => (b -> f b) -> m (f a) -> f (m a)` | `crocks/pointfree` |\n| `snd` | `m a b -> b` | `crocks/Pair` |\n| `swap` | `(c -> d) -> (a -> b) -> m c a -> m b d` | `crocks/pointfree` |\n| `tail` | `m a -> Maybe (m a)` | `crocks/pointfree` |\n| `traverse` | `Applicative f => (c -> f c) -> (a -> f b) -> m (f a) -> f (m b)` | `crocks/pointfree` |\n| `valueOf` | `m a -> a` | `crocks/pointfree` |\n\n##### Datatypes\n| Function | Datatypes |\n|---|:---|\n| `alt` | `Async`, `Either`, `Maybe`, `Result` |\n| `ap` | `Array`, `Async`, `Const`, `Either`, `Identity`, `IO`, `List`, `Maybe`, `Pair`, `Reader`, `Result`, `State`, `Unit`, `Writer` |\n| `bimap` | `Async`, `Either`, `Pair`, `Result` |\n| `both` | `Arrow`, `Function`, `Star` |\n| `chain` | `Array`, `Async`, `Const`, `Either`, `Identity`, `IO`, `List`, `Maybe`, `Pair`, `Reader`, `Result`, `State`, `Unit`, `Writer` |\n| `coalesce` | `Async`, `Either`, `Maybe`, `Result` |\n| `concat` | `All`, `Any`, `Array`, `Assign`, `Const`, `Either`, `Endo`, `First`, `Identity`, `Last`, `List`, `Max`, `Maybe`, `Min`, `Pair`, `Pred`, `Prod`, `Result`, `String`, `Sum`, `Unit` |\n| `cons` | `Array`, `List` |\n| `contramap` | `Arrow`, `Pred`, `Star` |\n| `either` | `Either`, `Maybe`, `Result` |\n| `empty` | `All`, `Any`, `Array`, `Assign`, `Endo`, `First`, `Last`, `List`, `Max`, `Min`, `Object`, `Pred`, `Prod`, `String`, `Sum`, `Unit` |\n| `evalWith` | `State` |\n| `execWith` | `State` |\n| `extend` | `Pair` |\n| `filter` | `Array`, `List`, `Object` |\n| `first` | `Arrow`, `Function`, `Star` |\n| `fold` | `Array`, `List` |\n| `fst` | `Pair` |\n| `head` | `Array`, `List`, `String` |\n| `log` | `Writer` |\n| `map` | `Async`, `Array`, `Arrow`, `Const`, `Either`, `Function`, `Identity`, `IO`, `List`, `Maybe`, `Object`, `Pair`, `Reader`, `Result`, `Star`, `State`, `Unit`, `Writer` |\n| `merge` | `Pair` |\n| `option` | `First`, `Last`, `Maybe` |\n| `promap` | `Arrow`, `Star` |\n| `read` | `Writer` |\n| `reduce` | `Array`, `List` |\n| `reject` | `Array`, `List`, `Object` |\n| `run` | `IO` |\n| `runWith` | `Arrow`, `Endo`, `Pred`, `Reader`, `Star`, `State` |\n| `second` | `Arrow`, `Function`, `Star` |\n| `sequence` | `Array`, `Either`, `Identity`, `List`, `Maybe`, `Result` |\n| `snd` | `Pair` |\n| `swap` | `Async`, `Either`, `Pair`, `Result` |\n| `tail` | `Array`, `List`, `String` |\n| `traverse` | `Array`, `Either`, `Identity`, `List`, `Maybe`, `Result` |\n| `valueOf` | `All`, `Any`, `Assign`, `Const`, `Endo`, `First`, `Identity`, `Last`, `Max`, `Min`, `Pred`, `Prod`, `Sum`, `Unit`, `Writer` |\n\n### Transformation Functions\nTransformation functions are mostly used to reduce unwanted nesting of similar\ntypes. Take for example the following structure:\n\n```javascript\nconst data =\n  Either.of(Maybe.of(3))  // Right Just 3\n\n// mapping on the inner Maybe is tedious at best\ndata\n  .map(map(x => x + 1))   // Right Just 4\n  .map(map(x => x * 10))  // Right Just 40\n\n// and extraction...super gross\ndata\n  .either(identity, identity)  // Just 3\n  .option(0)                   // 3\n\n// or\ndata\n  .either(option(0), option(0))  // 3\n```\n\nThe transformation functions, that ship with `crocks`, provide a means for\ndealing with this. Using them effectively, can turn the above code into\nsomething more like this:\n\n```javascript\nconst data =\n  Either.of(Maybe.of(3))      // Right Just 3\n    .chain(maybeToEither(0))  // Right 3\n\n// mapping on a single Either, much better\ndata\n  .map(x => x + 1)  // Right 4\n  .map(x => x * 10) // Right 40\n\n// no need to default the Left case anymore\ndata\n  .either(identity, identity) // 3\n\n// effects of the inner type are applied immediately\nconst nested =\n  Either.of(Maybe.Nothing) // Right Nothing\n\nconst unnested =\n  nested\n    .chain(maybeToEither(0))  // Left 0\n\n// Always maps, although the inner Maybe skips\nnested\n  .map(map(x => x + 1))        // Right Nothing (runs mapping)\n  .map(map(x => x * 10))       // Right Nothing (runs mapping)\n  .either(identity, identity)  // Nothing\n  .option(0)                   // 0\n\n// Never maps on a Left, just skips it\nunnested\n  .map(x => x + 1)             // Left 0 (skips mapping)\n  .map(x => x * 10)            // Left 0 (skips mapping)\n  .either(identity, identity)  // 0\n```\n\nNot all types can be transformed to and from each other. Some of them are lazy\nand/or asynchronous, or are just too far removed. Also, some transformations\nwill result in a loss of information. Moving from an `Either` to a `Maybe`, for\ninstance, would lose the `Left` value of `Either` as a `Maybe`'s first parameter\n(`Nothing`) is fixed at `Unit`. Conversely, if you move the other way around,\nfrom a `Maybe` to an `Either` you must provide a default `Left` value. Which\nmeans, if the inner `Maybe` results in a `Nothing`, it will map to `Left` of\nyour provided value. As such, not all of these functions are guaranteed\nisomorphic. With some types you just cannot go back and forth and expect to\nretain information.\n\nEach function provides two signatures, one for if a Function is used for the\nsecond argument and another if the source ADT is passed instead. Although it may\nseem strange, this provides some flexibility on how to apply the transformation.\nThe ADT version is great for squishing an already nested type or to perform the\ntransformation in a composition. While the Function version can be used to\nextend an existing function without having to explicitly compose it. Both\nversions can be seen here:\n\n```javascript\n// Avoid nesting\n// inc :: a -> Maybe Number\nconst inc =\n  safeLift(isNumber, x => x + 1)\n\n// using Function signature\n// asyncInc :: a -> Async Number Number\nconst asyncInc =\n  maybeToAsync(0, inc)\n\n// using ADT signature to compose (extending functions)\n// asyncInc :: a -> Async Number Number\nconst anotherInc =\n  compose(maybeToAsync(0), inc)\n\n// resolveValue :: a -> Async _ a\nconst resolveValue =\n  Async.Resolved\n\nresolveValue(3)                          // Resolved 3\n  .chain(asyncInc)                       // Resolved 4\n  .chain(anotherInc)                     // Resolved 5\n  .chain(compose(maybeToAsync(20), inc)) // Resolved 6\n\nresolveValue('oops')                     // Resolved 'oops'\n  .chain(asyncInc)                       // Rejected 0\n  .chain(anotherInc)                     // Rejected 0\n  .chain(compose(maybeToAsync(20), inc)) // Rejected 0\n\n// Squash existing nesting\n// Just Right 'nice'\nconst good =\n  Maybe.of(Either.Right('nice'))\n\n// Just Left 'not so nice'\nconst bad =\n  Maybe.of(Either.Left('not so nice'))\n\ngood\n  .chain(eitherToMaybe) // Just 'nice'\n\nbad\n  .chain(eitherToMaybe) // Nothing\n```\n\n#### Transformation Signatures\n| Transform | ADT signature | Function Signature | Location |\n|---|:---|:---|:---|\n| `arrayToList` | `[ a ] -> List a` | `(a -> [ b ]) -> a -> List b` | `crocks/List` |\n| `eitherToAsync` | `Either e a -> Async e a` | `(a -> Either e b) -> a -> Async e b` | `crocks/Async` |\n| `eitherToFirst` | `Either b a -> First a` | `(a -> Either c b) -> a -> First b` | `crocks/First` |\n| `eitherToLast` | `Either b a -> Last a` | `(a -> Either c b) -> a -> Last b` | `crocks/Last` |\n| `eitherToMaybe` | `Either b a -> Maybe a` | `(a -> Either c b) -> a -> Maybe b` | `crocks/Maybe` |\n| `eitherToResult` | `Either e a -> Result e a` | `(a -> Either e b) -> a -> Result e b` | `crocks/Result` |\n| `firstToAsync` | `e -> First a -> Async e a` | `e -> (a -> First b) -> a -> Async e b` | `crocks/Async` |\n| `firstToEither` | `c -> First a -> Either c a` | `c -> (a -> First b) -> a -> Either c b` | `crocks/Either` |\n| `firstToLast` | `First a -> Last a` | `(a -> First b) -> a -> Last b` | `crocks/Last` |\n| `firstToMaybe` | `First a -> Maybe a` | `(a -> First b) -> a -> Maybe b` | `crocks/Maybe` |\n| `firstToResult` | `c -> First a -> Result c a` | `c -> (a -> First b) -> a -> Result c b` | `crocks/Result` |\n| `lastToAsync` | `e -> Last a -> Async e a` | `e -> (a -> Last b) -> a -> Async e b` | `crocks/Async` |\n| `lastToEither` | `c -> Last a -> Either c a` | `c -> (a -> Last b) -> a -> Either c b` | `crocks/Either` |\n| `lastToFirst` | `Last a -> First a` | `(a -> Last b) -> a -> First b` | `crocks/First` |\n| `lastToMaybe` | `Last a -> Maybe a` | `(a -> Last b) -> a -> Maybe b` | `crocks/Maybe` |\n| `lastToResult` | `c -> Last a -> Result c a` | `c -> (a -> Last b) -> a -> Result c b` | `crocks/Result` |\n| `listToArray` | `List a -> [ a ]` | `(a -> List b) -> a -> [ b ]` | `crocks/List` |\n| `maybeToAsync` | `e -> Maybe a -> Async e a` | `e -> (a -> Maybe b) -> a -> Async e b` | `crocks/Async` |\n| `maybeToEither` | `c -> Maybe a -> Either c a` | `c -> (a -> Maybe b) -> a -> Either c b` | `crocks/Either` |\n| `maybeToFirst` | `Maybe a -> First a` | `(a -> Maybe b) -> a -> First b` | `crocks/First` |\n| `maybeToLast` | `Maybe a -> Last a` | `(a -> Maybe b) -> a -> Last b` | `crocks/Last` |\n| `maybeToResult` | `c -> Maybe a -> Result c a` | `c -> (a -> Maybe b) -> a -> Result c b` | `crocks/Result` |\n| `resultToAsync` | `Result e a -> Async e a` | `(a -> Result e b) -> a -> Async e b` | `crocks/Async` |\n| `resultToEither` | `Result e a -> Either e a` | `(a -> Result e b) -> a -> Either e b` | `crocks/Either` |\n| `resultToFirst` | `Result e a -> First a` | `(a -> Result e b) -> a -> First b` | `crocks/First` |\n| `resultToLast` | `Result e a -> Last a` | `(a -> Result e b) -> a -> Last b` | `crocks/Last` |\n| `resultToMaybe` | `Result e a -> Maybe a` | `(a -> Result e b) -> a -> Maybe b` | `crocks/Maybe` |\n| `writerToPair` | `Writer m a -> Pair m a` | `(a -> Writer m b) -> a -> Pair m b` | `crocks/Pair` |\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/evilsoft/crocks.git"
  },
  "scripts": {
    "build": "rm -rf build && buble -i src -o build && npm run build:dist",
    "build:dist": "webpack && uglifyjs build/dist/crocks.js -c \"warnings=false\" -m -o build/dist/crocks.min.js",
    "build:publish": "npm test && ./bin/publish",
    "coverage": "nyc report --reporter=text-lcov | coveralls",
    "lint": "eslint .",
    "preversion": "npm run build",
    "spec:build": "npm run build && tape build/**/*.spec.js build/*.spec.js",
    "spec:coverage": "nyc npm run spec:build",
    "spec:dev": "nodemon -q -e js -w src -x 'npm run spec:src -s | tap-spec'",
    "spec:src": "tape src/**/*.spec.js src/*.spec.js",
    "test": "npm run lint && npm run spec:coverage"
  },
  "version": "0.8.1"
}
