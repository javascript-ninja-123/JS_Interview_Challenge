(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["crocks"] = factory();
	else
		root["crocks"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 225);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// isFunction : a -> Boolean
function isFunction(fn) {
  return typeof fn === 'function'
}

module.exports = isFunction


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

function applyCurry(fn, arg) {
  if(!isFunction(fn)) { return fn }
  return fn.length > 1 ? fn.bind(null, arg) : fn.call(null, arg)
}

// curry : ((a, b, c) -> d) -> a -> b -> c -> d
function curry(fn) {
  return function() {
    var xs = [], len = arguments.length;
    while ( len-- ) xs[ len ] = arguments[ len ];

    var args =
      xs.length ? xs : [ undefined ]

    if(args.length < fn.length) {
      return curry(Function.bind.apply(fn, [ null ].concat(args)))
    }

    var val = (args.length === fn.length)
      ? fn.apply(null, args)
      : args.reduce(applyCurry, fn)

    if(isFunction(val)) {
      return curry(val)
    }

    return val
  }
}

module.exports = curry


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var type = __webpack_require__(53)

// isSameType :: Container m => (m, m) -> Boolean
function isSameType(x, y) {
  var tX = type(x)
  var tY = type(y)

  return tX === tY
    || (isFunction(x) && x.name === tY)
    || (isFunction(y) && y.name === tX)
}

module.exports = curry(isSameType)


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _types = {
  'unk': function () { return 'unknown'; },
  'All': function () { return 'All'; },
  'Any': function () { return 'Any'; },
  'Arrow': function () { return 'Arrow'; },
  'Assign': function () { return 'Assign'; },
  'Async': function () { return 'Async'; },
  'Const': function () { return 'Const'; },
  'Either': function () { return 'Either'; },
  'Endo': function () { return 'Endo'; },
  'First': function () { return 'First'; },
  'Identity': function () { return 'Identity'; },
  'IO': function () { return 'IO'; },
  'Last': function () { return 'Last'; },
  'List': function () { return 'List'; },
  'Max': function () { return 'Max'; },
  'Maybe': function () { return 'Maybe'; },
  'Min': function () { return 'Min'; },
  'Pair': function () { return 'Pair'; },
  'Pred': function () { return 'Pred'; },
  'Prod': function () { return 'Prod'; },
  'Reader': function () { return 'Reader'; },
  'Result': function () { return 'Result'; },
  'Star': function () { return 'Star'; },
  'State': function () { return 'State'; },
  'Sum': function () { return 'Sum'; },
  'Unit': function () { return 'Unit'; },
  'Writer': function () { return 'Writer'; },
}


var type =
  function (type) { return _types[type] || _types['unk']; }

var proxy =
  function (t) { return ({ type: type(t) }); }

module.exports = {
  proxy: proxy, type: type
}


/***/ }),
/* 4 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var fulfills =
  function (algs) { return function (test) { return algs.indexOf(test) !== -1; }; }

module.exports = fulfills


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isArray = __webpack_require__(7)
var isFunction = __webpack_require__(0)
var isObject = __webpack_require__(8)
var isString = __webpack_require__(10)

function arrayInspect(xs) {
  return xs.length
    ? xs.map(inspect).reduce(function (a, x) { return a + ',' + x; })
    : xs
}

// inspect : a -> String
function inspect(x) {
  if(x && isFunction(x.inspect)) {
    return (" " + (x.inspect()))
  }

  if(isFunction(x)) {
    return ' Function'
  }

  if(isArray(x)) {
    return (" [" + (arrayInspect(x)) + " ]")
  }

  if(isObject(x)) {
    return ' {}'
  }

  if(isString(x)) {
    return (" \"" + x + "\"")
  }

  return (" " + x)
}

module.exports = inspect


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

var hasAlg = function (alg, m) { return isFunction(m[alg]) || (isFunction(m['@@implements']) && !!m['@@implements'](alg)); }

module.exports = hasAlg


/***/ }),
/* 7 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

function isArray(x) {
  return Array.isArray(x)
}

module.exports = isArray


/***/ }),
/* 8 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// isObject : a -> Boolean
function isObject(x) {
  return !!x
    && x.toString
    && x.toString() === '[object Object]'
}

module.exports = isObject


/***/ }),
/* 9 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// Composition (Bluebird)
// compose : (b -> c) -> (a -> b) -> a -> c
function compose(f, g) {
  return function(x) {
    return f(g(x))
  }
}

module.exports = compose


/***/ }),
/* 10 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// isString : a -> Boolean
function isString(x) {
  return typeof x === 'string'
}

module.exports = isString


/***/ }),
/* 11 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// isNil : a -> Boolean
function isNil(x) {
  return x === undefined
    || x === null
    || Number.isNaN(x)
}

module.exports = isNil


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)

// isFoldable : a -> Boolean
function isFoldable(m) {
  return !!m
    && hasAlg('reduce', m)
}

module.exports = isFoldable


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isApply = __webpack_require__(29)

// isApplicative : a -> Boolean
function isApplicative(m) {
  return isApply(m)
    && hasAlg('of', m)
}

module.exports = isApplicative


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _defineUnion = __webpack_require__(39)
var _equals = __webpack_require__(16)
var _implements = __webpack_require__(4)
var _innerConcat = __webpack_require__(31)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Maybe')

var compose = __webpack_require__(9)
var isApplicative = __webpack_require__(13)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }
var identity = function (x) { return x; }

var _maybe =
  _defineUnion({ Nothing: [], Just: [ 'a' ] })

var Nothing =
  _maybe.Nothing

var Just =
  _maybe.Just

Maybe.Nothing =
  compose(Maybe, Nothing)

Maybe.Just =
  compose(Maybe, Just)

var _of =
  compose(Maybe, Just)

var _zero =
  compose(Maybe, Nothing)

function Maybe(u) {
  if(!arguments.length) {
    throw new TypeError('Maybe: Must wrap something, try using Nothing or Just constructors')
  }

  var x =
    !_maybe.includes(u) ? Just(u) : u

  var of =
    _of

  var zero =
    _zero

  var option =
    function (n) { return either(constant(n), identity); }

  var equals =
    function (m) { return isSameType(Maybe, m) && either(
      constant(m.either(constant(true), constant(false))),
      function (x) { return m.either(constant(false), function (y) { return _equals(y, x); }); }
    ); }

  var inspect = function () { return either(
      constant('Nothing'),
      function (x) { return ("Just" + (_inspect(x))); }
    ); }

  function either(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Maybe.either: Requires both left and right functions')
    }

    return _maybe.caseOf({
      Nothing: f,
      Just: g
    }, x)
  }

  function concat(m) {
    if(!isSameType(Maybe, m)) {
      throw new TypeError('Maybe.concat: Maybe of Semigroup required')
    }

    return either(
      Maybe.Nothing,
      _innerConcat(Maybe, m)
    )
  }

  function coalesce(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Maybe.coalesce: Requires both left and right functions')
    }

    return Maybe.Just(either(f, g))
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Maybe.map: Function required')
    }

    return either(
      Maybe.Nothing,
      compose(Maybe.Just, fn)
    )
  }

  function alt(m) {
    if(!isSameType(Maybe, m)) {
      throw new TypeError('Maybe.alt: Maybe required')
    }

    return either(
      constant(m),
      Maybe.Just
    )
  }

  function ap(m) {
    var fn = option(constant(undefined))

    if(!isFunction(fn)) {
      throw new TypeError('Maybe.ap: Wrapped value must be a function')
    }
    else if(!isSameType(Maybe, m)) {
      throw new TypeError('Maybe.ap: Maybe required')
    }

    return either(
      Maybe.Nothing,
      m.map
    )
  }

  function chain(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Maybe.chain: Function required')
    }

    var m = either(Maybe.Nothing, fn)

    if(!isSameType(Maybe, m)) {
      throw new TypeError('Maybe.chain: Function must return a Maybe')
    }

    return m
  }

  function runSequence(x) {
    if(!isApplicative(x)) {
      throw new TypeError('Maybe.sequence: Must wrap an Applicative')
    }

    return x.map(Maybe.of)
  }

  function sequence(af) {
    if(!isFunction(af)) {
      throw new TypeError('Maybe.sequence: Applicative returning function required')
    }

    return either(
      compose(af, Maybe.Nothing),
      runSequence
    )
  }

  function traverse(af, f) {
    if(!isFunction(f) || !isFunction(af)) {
      throw new TypeError('Maybe.traverse: Applicative returning functions required for both arguments')
    }

    var m = either(compose(af, Maybe.Nothing), f)

    if(!isApplicative(m)) {
      throw new TypeError('Maybe.traverse: Both functions must return an Applicative')
    }

    return either(
      constant(m),
      constant(m.map(Maybe))
    )
  }

  return {
    inspect: inspect, either: either, option: option, type: type,
    concat: concat, equals: equals, coalesce: coalesce, map: map, alt: alt,
    zero: zero, ap: ap, of: of, chain: chain, sequence: sequence,
    traverse: traverse
  }
}

Maybe.of =
  _of

Maybe.type =
  type

Maybe.zero =
  _zero

Maybe['@@implements'] = _implements(
  [ 'alt', 'ap', 'chain', 'concat', 'equals', 'map', 'of', 'traverse', 'zero' ]
)

module.exports = Maybe


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isApplicative = __webpack_require__(13)
var isArray = __webpack_require__(7)
var isFunction = __webpack_require__(0)

var identity = function (x) { return x; }

var concat =
  function (x) { return function (m) { return m.concat(x); }; }

function runTraverse(name, fn) {
  return function(acc, x) {
    var m = fn(x)

    if(!isApplicative(acc) || !isApplicative(m)) {
      throw new TypeError(("Array." + name + ": Must wrap Applicatives"))
    }

    return m
      .map(function (v) { return concat([ v ]); })
      .ap(acc)
  }
}

var allFuncs =
  function (xs) { return xs.reduce(function (b, i) { return b && isFunction(i); }, true); }

var map =
  function (f, m) { return m.map(function (x) { return f(x); }); }

function ap(x, m) {
  if(!(m.length && allFuncs(m))) {
    throw new TypeError('Array.ap: Second Array must all be functions')
  }

  return m.reduce(function (acc, f) { return acc.concat(map(f, x)); }, [])
}

function chain(f, m) {
  return m.reduce(function(y, x) {
    var n = f(x)

    if(!isArray(n)) {
      throw new TypeError('Array.chain: Function must return an Array')
    }

    return y.concat(n)
  }, [])
}

function sequence(af, m) {
  return m.reduce(runTraverse('sequence', identity), af([]))
}

function traverse(af, fn, m) {
  return m.reduce(runTraverse('traverse', fn), af([]))
}

module.exports = {
  ap: ap, chain: chain, map: map, sequence: sequence, traverse: traverse
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isSameType = __webpack_require__(2)
var isSame = __webpack_require__(51)
var hasAlg = __webpack_require__(6)
var type = __webpack_require__(53)

var comp = function (a, b) { return a.valueOf() === b.valueOf(); }

var strats = {
  'Array': function (a, b) { return a.length === b.length
      && deepEquals(a, b); },

  'Date': function (a, b) { return isSame(a.valueOf(), b.valueOf()); },

  'Error': function (a, b) { return a.name === b.name
      && a.message === b.message; },

  'Object': function (a, b) { return Object.keys(a).length === Object.keys(b).length
      && deepEquals(a, b); },

  'RegExp': function (a, b) { return a.source === b.source
      && a.ignoreCase === b.ignoreCase
      && a.global === b.global
      && a.multiline === b.multiline
      && a.unicode === b.unicode; }
}

function deepEquals(a, b) {
  for(var key in a) {
    if(!equals(a[key], b[key])) {
      return false
    }
  }
  return true
}

function equals(a, b) {
  if(isSame(a, b)) {
    return true
  }

  if(!isSameType(a, b)) {
    return false
  }

  if(hasAlg('equals', a)) {
    return a.equals(b)
  }
  return (strats[type(a)] || comp)(a, b)
}

module.exports = equals


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

function predOrFunc(pred, x) {
  if(isFunction(pred)) {
    return pred(x)
  }
  return pred.runWith(x)
}

module.exports = predOrFunc


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isString = __webpack_require__(10)
var hasAlg = __webpack_require__(6)

// isSemigroup : a -> Boolean
function isSemigroup(m) {
  return isString(m)
    || (!!m && hasAlg('concat', m))
}

module.exports = isSemigroup


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _equals = __webpack_require__(16)
var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Pair')

var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)
var isSemigroup = __webpack_require__(18)

function Pair(l, r) {
  if(arguments.length < 2) {
    throw new TypeError('Pair: Must provide a first and second value')
  }

  var fst =
    function () { return l; }

  var snd =
    function () { return r; }

  var inspect =
    function () { return ("Pair(" + (_inspect(l)) + "," + (_inspect(r)) + " )"); }

  var toArray =
    function () { return [ l, r ]; }

  function merge(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Pair.merge: Binary function required')
    }

    return fn(fst(), snd())
  }

  function equals(m) {
    return isSameType(Pair, m)
      && _equals(m.fst(), fst())
      && _equals(m.snd(), snd())
  }

  function concat(m) {
    if(!(m && isSameType(Pair, m))) {
      throw new TypeError('Pair.concat: Pair required')
    }

    var lf = fst()
    var ls = snd()
    var rf = m.fst()
    var rs = m.snd()

    if(!(isSemigroup(lf) && isSemigroup(ls))) {
      throw new TypeError('Pair.concat: Both Pairs must contain Semigroups of the same type')
    }

    if(!(isSameType(lf, rf) && isSameType(ls, rs))) {
      throw new TypeError('Pair.concat: Both Pairs must contain Semigroups of the same type')
    }

    return Pair(
      lf.concat(rf),
      ls.concat(rs)
    )
  }

  function swap(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Pair.swap: Requires both left and right functions')
    }

    return Pair(g(r), f(l))
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Pair.map: Function required')
    }

    return Pair(l, fn(r))
  }

  function bimap(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Pair.bimap: Function required for both arguments')
    }

    return Pair(f(l), g(r))
  }

  function ap(m) {
    if(!(isSameType(Pair, m))) {
      throw new TypeError('Pair.ap: Pair required')
    }

    var fn = snd()

    if(!isFunction(fn)) {
      throw new TypeError('Pair.ap: Function required for second value')
    }

    var l = fst()
    var r = m.fst()

    if(!(isSemigroup(l) && isSameType(l, r))) {
      throw new TypeError('Pair.ap: Semigroups of the same type is required for first values')
    }

    return Pair(l.concat(r), fn(m.snd()))
  }

  function chain(fn) {
    var l = fst()

    if(!isFunction(fn)) {
      throw new TypeError('Pair.chain: Function required')
    }

    if(!isSemigroup(l)) {
      throw new TypeError('Pair.chain: Semigroups of the same type required for first values')
    }

    var m = fn(snd())

    if(!(isSameType(Pair, m))) {
      throw new TypeError('Pair.chain: Function must return a Pair')
    }

    var r = m.fst()

    if(!isSameType(l, r)) {
      throw new TypeError('Pair.chain: Semigroups of the same type required for first values')
    }

    return Pair(
      l.concat(r),
      m.snd()
    )
  }

  function extend(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Pair.extend: Function required')
    }

    return Pair(l, fn(Pair(l, r)))
  }

  return {
    inspect: inspect, fst: fst, snd: snd, toArray: toArray,
    type: type, merge: merge, equals: equals, concat: concat,
    swap: swap, map: map, bimap: bimap, ap: ap, chain: chain,
    extend: extend
  }
}

Pair.type =
  type

Pair['@@implements'] = _implements(
  [ 'ap', 'bimap', 'chain', 'concat', 'extend', 'equals', 'map' ]
)

module.exports = Pair


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)

// isFunctor : a -> Boolean
function isFunctor(m) {
  return !!m && hasAlg('map', m)
}

module.exports = isFunctor


/***/ }),
/* 21 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// isNumber : a -> Boolean
function isNumber(x) {
  return typeof x === 'number'
    && !isNaN(x)
}

module.exports = isNumber


/***/ }),
/* 22 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

function rejectUnit(obj) {
  return function(acc, key) {
    var value = obj[key]

    if(value !== undefined) {
      acc[key] = value
    }
    return acc
  }
}

function assign(x, m) {
  var result = Object.keys(m).reduce(rejectUnit(m), {})
  return Object.keys(x).reduce(rejectUnit(x), result)
}

function filter(f, m) {
  return Object.keys(m).reduce(function (acc, key) {
    if(f(m[key])) {
      acc[key] = m[key]
    }
    return acc
  }, {})
}

function map(f, m) {
  return Object.keys(m).reduce(function (acc, key) {
    acc[key] = f(m[key])
    return acc
  }, {})
}

module.exports = {
  assign: assign,
  filter: filter,
  map: map
}


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Async')

var array = __webpack_require__(15)
var compose = __webpack_require__(9)
var once = __webpack_require__(52)
var unit = __webpack_require__(46)

var isArray = __webpack_require__(7)
var isFoldable = __webpack_require__(12)
var isFunction = __webpack_require__(0)
var isPromise = __webpack_require__(35)
var isSameType = __webpack_require__(2)

var allAsyncs = function (xs) { return xs.reduce(function (acc, x) { return acc && isSameType(Async, x); }, true); }

var _of =
  function (x) { return Async(function (_, resolve) { return resolve(x); }); }

var Rejected =
  function (x) { return Async(function (reject) { return reject(x); }); }

function all(asyncs) {
  if(!(isFoldable(asyncs) && allAsyncs(asyncs))) {
    throw new TypeError('Async.all: Foldable structure of Asyncs required')
  }

  if(isArray(asyncs)) {
    return array.sequence(Async.of, asyncs)
  }

  return asyncs.sequence(Async.of)
}

function fromNode(fn, ctx) {
  if(!isFunction(fn)) {
    throw new TypeError('Async.fromNode: CPS function required')
  }

  return function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return Async(function (reject, resolve) {
      fn.apply(ctx,
        args.concat(
          function (err, data) { return err ? reject(err) : resolve(data); }
        )
      )
    });
  }
}

function fromPromise(fn) {
  if(!isFunction(fn)) {
    throw new TypeError('Async.fromPromise: Promise returning function required')
  }

  return function() {
    var promiseArgs = arguments

    return Async(function(reject, resolve) {
      var promise = fn.apply(null, promiseArgs)

      if(!isPromise(promise)) {
        throw new TypeError('Async.fromPromise: Promise returning function required')
      }

      promise
        .then(resolve)
        .catch(reject)
    })
  }
}

function Async(fn, parentCancel) {
  if(!isFunction(fn)) {
    throw new TypeError('Async: Function required')
  }

  var cancelled

  var cancel = compose(
    function () { cancelled = true },
    isFunction(parentCancel) ? parentCancel : unit
  )

  var of =
    _of

  var inspect =
    function () { return ("Async" + (_inspect(fn))); }

  function fork(reject, resolve, cleanup) {
    if(!isFunction(reject) || !isFunction(resolve)) {
      throw new TypeError('Async.fork: Reject and resolve functions required')
    }

    var forkCancel =
      isFunction(cleanup) ? cleanup : unit

    fn(
      function (x) { return cancelled ? unit() : reject(x); },
      function (x) { return cancelled ? unit() : resolve(x); }
    )

    return once(compose(forkCancel, cancel))
  }

  function toPromise() {
    return new Promise(function(resolve, reject) {
      fork(reject, resolve)
    })
  }

  function swap(l, r) {
    if(!isFunction(l) || !isFunction(r)) {
      throw new TypeError('Async.swap: Functions required for both arguments')
    }

    return Async(function(reject, resolve) {
      fork(
        compose(resolve, l),
        compose(reject, r)
      )
    }, cancel)
  }

  function coalesce(l, r) {
    if(!isFunction(l) || !isFunction(r)) {
      throw new TypeError('Async.coalesce: Functions required for both arguments')
    }

    return Async(function(reject, resolve) {
      fork(
        compose(resolve, l),
        compose(resolve, r)
      )
    }, cancel)
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Async.map: Function required')
    }

    return Async(function(reject, resolve) {
      fork(reject, compose(resolve, fn))
    }, cancel)
  }

  function bimap(l, r) {
    if(!isFunction(l) || !isFunction(r)) {
      throw new TypeError('Async.bimap: Functions required for both arguments')
    }

    return Async(function(reject, resolve) {
      fork(
        compose(reject, l),
        compose(resolve, r)
      )
    }, cancel)
  }

  function alt(m) {
    var innerCancel = unit

    if(!isSameType(Async, m)) {
      throw new TypeError('Async.alt: Async required')
    }

    return Async(function (rej, res) {
      fork(
        function () { innerCancel = m.fork(rej, res) },
        res
      )
    }, once(function () { return innerCancel(cancel()); }))
  }

  function ap(m) {
    var fn, value
    var fnDone = false
    var valueDone = false
    var innerCancel = unit

    if(!isSameType(Async, m)) {
      throw new TypeError('Async.ap: Async required')
    }

    return Async(function(reject, resolve) {
      var rejectOnce = once(reject)

      function resolveBoth() {
        if(fnDone && valueDone) {
          compose(resolve, fn)(value)
        }
      }

      fork(rejectOnce, function(f) {
        if(!isFunction(f)) {
          throw new TypeError('Async.ap: Wrapped value must be a function')
        }

        fnDone = true
        fn = f
        resolveBoth()
      })

      innerCancel = m.fork(rejectOnce, function (x) {
        valueDone = true
        value = x
        resolveBoth()
      })
    }, once(function () { innerCancel(cancel()) }))
  }

  function chain(fn) {
    var innerCancel = unit

    if(!isFunction(fn)) {
      throw new TypeError('Async.chain: Async returning function required')
    }

    return Async(function(reject, resolve) {
      fork(reject, function(x) {
        var m = fn(x)

        if(!isSameType(Async, m)) {
          throw new TypeError('Async.chain: Function must return another Async')
        }

        innerCancel = m.fork(reject, resolve)
      })
    }, once(function () { innerCancel(cancel()) }))
  }

  return {
    fork: fork, toPromise: toPromise, inspect: inspect, type: type,
    swap: swap, coalesce: coalesce, map: map, bimap: bimap, alt: alt,
    ap: ap, chain: chain, of: of
  }
}

Async.type = type
Async.of = _of

Async.Rejected = Rejected
Async.Resolved = _of

Async.fromPromise = fromPromise
Async.fromNode = fromNode

Async.all = all

Async['@@implements'] = _implements(
  [ 'alt', 'ap', 'bimap', 'chain', 'map', 'of' ]
)

module.exports = Async


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _defineUnion = __webpack_require__(39)
var _equals = __webpack_require__(16)
var _implements = __webpack_require__(4)
var _innerConcat = __webpack_require__(31)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Result')

var compose = __webpack_require__(9)
var isApplicative = __webpack_require__(13)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)
var isSemigroup = __webpack_require__(18)

var constant = function (x) { return function () { return x; }; }

var _result =
  _defineUnion({ Err: [ 'a' ], Ok: [ 'b' ] })

Result.Err =
  compose(Result, _result.Err)

Result.Ok =
  compose(Result, _result.Ok)

var _of =
  Result.Ok

var concatApErr =
  function (m) { return function (x) { return Result.Err(m.either(
    function (y) { return isSemigroup(x) && isSameType(y, x) ? x.concat(y) : x; },
    function () { return x; }
  )); }; }

var concatAltErr =
  function (r) { return function (l) { return Result.Err(isSemigroup(r) && isSameType(l, r) ? l.concat(r) : r); }; }

function runSequence(x) {
  if(!isApplicative(x)) {
    throw new TypeError('Result.sequence: Must wrap an Applicative')
  }

  return x.map(Result.of)
}

function Result(u) {
  if(!arguments.length) {
    throw new TypeError('Result: Must wrap something, try using Err or Ok constructors')
  }

  var x =
    !_result.includes(u) ? _result.Ok(u) : u

  var equals =
    function (m) { return isSameType(Result, m) && either(
      function (x) { return m.either(function (y) { return _equals(y, x); }, constant(false)); },
      function (x) { return m.either(constant(false), function (y) { return _equals(y, x); }); }
    ); }

  var of =
    _of

  var inspect = function () { return either(
      function (l) { return ("Err" + (_inspect(l))); },
      function (r) { return ("Ok" + (_inspect(r))); }
    ); }

  function either(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Result.either: Requires both invalid and valid functions')
    }

    return _result.caseOf({
      Err: f,
      Ok: g
    }, x)
  }

  function concat(m) {
    if(!isSameType(Result, m)) {
      throw new TypeError('Result.concat: Result of Semigroup required')
    }

    return either(
      Result.Err,
      _innerConcat(Result, m)
    )
  }

  function swap(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Result.swap: Requires both left and right functions')
    }

    return either(
      compose(Result.Ok, f),
      compose(Result.Err, g)
    )
  }

  function coalesce(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Result.coalesce: Requires both left and right functions')
    }

    return Result.Ok(either(f, g))
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Result.map: function required')
    }

    return either(
      Result.Err,
      compose(Result.Ok, fn)
    )
  }

  function bimap(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Result.bimap: Requires both left and right functions')
    }

    return either(
      compose(Result.Err, f),
      compose(Result.Ok, g)
    )
  }

  function alt(m) {
    if(!isSameType(Result, m)) {
      throw new TypeError('Result.alt: Result required')
    }

    return m.either(
      function (r) { return either(concatAltErr(r), Result.Ok); },
      function (r) { return either(function () { return Result.Ok(r); }, Result.Ok); }
    )
  }

  function ap(m) {
    if(!isSameType(Result, m)) {
      throw new TypeError('Result.ap: Result required')
    }

    return either(
      concatApErr(m),
      function(fn) {
        if(!isFunction(fn)) {
          throw new TypeError('Result.ap: Wrapped value must be a function')
        }

        return m.either(Result.Err, function () { return m.map(fn); })
      }
    )
  }

  function chain(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Result.chain: Result returning function required')
    }

    var m = either(Result.Err, fn)

    if(!isSameType(Result, m)) {
      throw new TypeError('Result.chain: Function must return a Result')
    }

    return m
  }

  function sequence(af) {
    if(!isFunction(af)) {
      throw new TypeError('Result.sequence: Applicative returning function required')
    }

    return either(
      compose(af, Result.Err),
      runSequence
    )
  }
  function traverse(af, f) {
    if(!isFunction(f) || !isFunction(af)) {
      throw new TypeError('Result.traverse: Applicative returning functions required for both arguments')
    }

    var m = either(compose(af, Result.Err), f)

    if(!isApplicative(m)) {
      throw new TypeError('Result.traverse: Both functions must return an Applicative')
    }

    return either(
      constant(m),
      constant(m.map(Result.Ok))
    )
  }

  return {
    inspect: inspect, equals: equals, type: type, either: either, concat: concat,
    swap: swap, coalesce: coalesce, map: map, bimap: bimap, alt: alt, ap: ap,
    chain: chain, of: of, sequence: sequence, traverse: traverse
  }
}

Result.of = _of
Result.type = type

Result['@@implements'] = _implements(
  [ 'alt', 'ap', 'bimap', 'chain', 'concat', 'equals', 'map', 'of', 'traverse' ]
)

module.exports = Result


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isSemigroup = __webpack_require__(18)

// isMonoid :: a -> Boolean
function isMonoid(m) {
  return isSemigroup(m)
    && hasAlg('empty', m)
}

module.exports = isMonoid


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _defineUnion = __webpack_require__(39)
var _equals = __webpack_require__(16)
var _implements = __webpack_require__(4)
var _innerConcat = __webpack_require__(31)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Either')

var compose = __webpack_require__(9)
var isApplicative = __webpack_require__(13)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

var _either =
  _defineUnion({ Left: [ 'a' ], Right: [ 'b' ] })

var Left = _either.Left;
var Right = _either.Right;

Either.Left =
  compose(Either, Left)

Either.Right =
  compose(Either, Right)

var _of =
  Either.Right

function runSequence(x) {
  if(!isApplicative(x)) {
    throw new TypeError('Either.sequence: Must wrap an Applicative')
  }

  return x.map(Either.of)
}

function Either(u) {
  if(!arguments.length) {
    throw new TypeError('Either: Must wrap something, try using Left or Right constructors')
  }

  var x = !_either.includes(u)
    ? Right(u)
    : u

  var equals =
    function (m) { return isSameType(Either, m) && either(
      function (x) { return m.either(function (y) { return _equals(y, x); }, constant(false)); },
      function (x) { return m.either(constant(false), function (y) { return _equals(y, x); }); }
    ); }

  var of =
    _of

  var inspect = constant(
    either(
       function (l) { return ("Left" + (_inspect(l))); },
       function (r) { return ("Right" + (_inspect(r))); }
    )
  )

  function either(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Either.either: Requires both left and right functions')
    }

    return _either.caseOf({
      Left: f,
      Right: g
    }, x)
  }

  function concat(m) {
    if(!isSameType(Either, m)) {
      throw new TypeError('Either.concat: Either of Semigroup required')
    }

    return either(
      Either.Left,
      _innerConcat(Either, m)
    )
  }

  function swap(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Either.swap: Requires both left and right functions')
    }

    return either(
      compose(Either.Right, f),
      compose(Either.Left, g)
    )
  }

  function coalesce(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Either.coalesce: Requires both left and right functions')
    }

    return Either.Right(either(f, g))
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Either.map: Function required')
    }

    return either(Either.Left, compose(Either.Right, fn))
  }

  function bimap(f, g) {
    if(!isFunction(f) || !isFunction(g)) {
      throw new TypeError('Either.bimap: Requires both left and right functions')
    }

    return either(
      compose(Either.Left, f),
      compose(Either.Right, g)
    )
  }

  function alt(m) {
    if(!isSameType(Either, m)) {
      throw new TypeError('Either.alt: Either required')
    }

    return either(
      constant(m),
      Either.Right
    )
  }

  function ap(m) {
    if(!either(constant(true), isFunction)) {
      throw new TypeError('Either.ap: Wrapped value must be a function')
    }
    else if(!either(constant(true), constant(isSameType(Either, m)))) {
      throw new TypeError('Either.ap: Either required')
    }

    return chain(function (fn) { return m.map(fn); })
  }

  function chain(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Either.chain: Function required')
    }

    var m = either(Either.Left, fn)

    if(!isSameType(Either, m)) {
      throw new TypeError('Either.chain: Function must return an Either')
    }

    return m
  }

  function sequence(af) {
    if(!isFunction(af)) {
      throw new TypeError('Either.sequence: Applicative returning function required')
    }

    return either(
      compose(af, Either.Left),
      runSequence
    )
  }

  function traverse(af, f) {
    if(!isFunction(f) || !isFunction(af)) {
      throw new TypeError('Either.traverse: Applicative returning functions required for both arguments')
    }

    var m = either(compose(af, Either.Left), f)

    if(!isApplicative(m)) {
      throw new TypeError('Either.traverse: Both functions must return an Applicative')
    }

    return either(
      constant(m),
      constant(m.map(Either.of))
    )
  }

  return {
    inspect: inspect, either: either, type: type, concat: concat,
    swap: swap, coalesce: coalesce, equals: equals, map: map, bimap: bimap,
    alt: alt, ap: ap, of: of, chain: chain, sequence: sequence, traverse: traverse
  }
}

Either.of   = _of
Either.type = type

Either['@@implements'] = _implements(
  [ 'alt', 'ap', 'bimap', 'chain', 'concat', 'equals', 'map', 'of', 'traverse' ]
)

module.exports = Either


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('First')

var isSameType = __webpack_require__(2)

var Maybe = __webpack_require__(14)

var _empty =
  function () { return First(Maybe.Nothing()); }

function First(x) {
  if(!arguments.length) {
    throw new TypeError('First: Requires one argument')
  }

  var maybe =
    !isSameType(Maybe, x) ? Maybe.of(x) : x.map(function (x) { return x; })

  var empty =
    _empty

  var inspect =
    function () { return ("First(" + (_inspect(maybe)) + " )"); }

  var valueOf =
    function () { return maybe; }

  var option =
    maybe.option

  function concat(m) {
    if(!isSameType(First, m)) {
      throw new TypeError('First.concat: First required')
    }

    var n =
      m.valueOf().map(function (x) { return x; })

    return First(
      maybe.either(function () { return n; }, Maybe.Just)
    )
  }

  return {
    concat: concat, empty: empty, inspect: inspect,
    option: option, type: type, valueOf: valueOf
  }
}

First['@@implements'] = _implements(
  [ 'concat', 'empty' ]
)

First.empty = _empty
First.type = type

module.exports = First


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Last')

var isSameType = __webpack_require__(2)

var Maybe = __webpack_require__(14)

var _empty =
  function () { return Last(Maybe.Nothing()); }

function Last(x) {
  if(!arguments.length) {
    throw new TypeError('Last: Requires one argument')
  }

  var maybe =
    !isSameType(Maybe, x) ? Maybe.of(x) : x.map(function (x) { return x; })

  var valueOf =
    function () { return maybe; }

  var empty =
    _empty

  var inspect =
    function () { return ("Last(" + (_inspect(maybe)) + " )"); }

  var option =
    maybe.option

  function concat(m) {
    if(!isSameType(Last, m)) {
      throw new TypeError('Last.concat: Last required')
    }

    var n =
      m.valueOf().map(function (x) { return x; })

    return Last(
      maybe.either(
        function () { return n; },
        function () { return n.either(function () { return maybe; }, function () { return n; }); }
      )
    )
  }

  return {
    concat: concat, empty: empty, inspect: inspect, option: option, type: type, valueOf: valueOf
  }
}

Last['@@implements'] = _implements(
  [ 'concat', 'empty' ]
)

Last.empty =
  _empty

Last.type =
  type

module.exports = Last


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isFunctor = __webpack_require__(20)

// isApply : a -> Boolean
function isApply(m) {
  return isFunctor(m)
    && hasAlg('ap', m)
}

module.exports = isApply


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)

// isSemigroupoid : a -> Boolean
function isSemigroupoid(m) {
  return !!m && hasAlg('compose', m)
}

module.exports = isSemigroupoid


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isSameType = __webpack_require__(2)
var isSemigroup = __webpack_require__(18)

function innerConcat(type, m) {
  var t = type.type()

  return function(left) {
    if(!isSemigroup(left)) {
      throw new TypeError((t + ".concat: Both containers must contain Semigroups of the same type"))
    }

    return m.map(function (right) {
      if(!isSameType(left, right)) {
        throw new TypeError((t + ".concat: Both containers must contain Semigroups of the same type"))
      }

      return left.concat(right)
    })
  }
}

module.exports = innerConcat


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isApply = __webpack_require__(29)

// isChain : a -> Boolean
function isChain(m) {
  return isApply(m)
    && hasAlg('chain', m)
}

module.exports = isChain


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */
var isObject = __webpack_require__(8)

function isEmpty(x) {
  if(isObject(x)) {
    return !Object.keys(x).length
  }

  if(x && x.length !== undefined) {
    return !x.length
  }

  return true
}

module.exports = isEmpty


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isNumber = __webpack_require__(21)

// isInteger : a -> Boolean
function isInteger(x) {
  return isNumber(x)
    && isFinite(x)
    && Math.floor(x) === x
}

module.exports = isInteger


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

// isPromise : a -> Boolean
function isPromise(p) {
  return !!p
    && isFunction(p.then)
    && isFunction(p.catch)
}

module.exports = isPromise


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var compose = __webpack_require__(9)

var foldWith =
  function (m) { return function (x, y) { return x.concat(m(y)); }; }

// mconcatMap :: Monoid M => M -> (b -> a) -> ([ b ] | List b) -> M a
function mconcatMap(M, f, xs) {
  return xs.reduce(foldWith(compose(M, f)), M.empty())
}

module.exports = mconcatMap


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(44)


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(14)


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isArray = __webpack_require__(7)
var isEmpty = __webpack_require__(33)
var isFunction = __webpack_require__(0)
var isObject = __webpack_require__(8)
var isString = __webpack_require__(10)

var constant = function (x) { return function () { return x; }; }

var isDefinition =
  function (x) { return isString(x) && x.length; }

function caseOf(defs) {
  return function(cases, m) {
    var tag = m.tag
    var def = defs[tag()]

    var args = def.reduce(
      function (xs, x) { return xs.concat([ m[x].value() ]); },
      []
    )

    return cases[tag()].apply(null, args)
  }
}

var includes =
  function (defs) { return function (m) { return !!m && isFunction(m.tag) && Object.keys(defs).indexOf(m.tag()) !== -1; }; }

function construction(def, tag) {
  return function() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return def.reduce(function(obj, key, index) {
      obj[key] = { value: constant(args[index]) }
      return obj
    }, { tag: constant(tag) })
  }
}

function defineUnion(defs) {
  if(!isObject(defs) || isEmpty(defs)) {
    throw new TypeError('defineUnion: Argument must be an Object containing definition lists')
  }

  return Object.keys(defs).reduce(function(obj, tag) {
    var def = defs[tag]

    if(!isArray(def) || !def.reduce(function (x, y) { return x && isDefinition(y); }, true)) {
      throw new TypeError('defineUnion: Definitions must be a list of non-empty string identifiers')
    }

    obj[tag] = construction(def, tag)

    return obj
  }, { caseOf: curry(caseOf(defs)), includes: curry(includes(defs)) })
}

module.exports = defineUnion


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isFunctor = __webpack_require__(20)

// isAlt : a -> Boolean
function isAlt(m) {
  return isFunctor(m)
    && hasAlg('alt', m)
}

module.exports = isAlt


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)

// isContravariant : a -> Boolean
function isContravariant(m) {
  return !!m && hasAlg('contramap', m)
}

module.exports = isContravariant


/***/ }),
/* 42 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

function isDefined(x) {
  return x !== undefined
}

module.exports = isDefined


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pred = __webpack_require__(3).proxy('Pred')
var ref = __webpack_require__(14);
var Nothing = ref.Nothing;
var Just = ref.Just;
var predOrFunc = __webpack_require__(17)

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

// safe : ((a -> Boolean) | Pred) -> a -> Maybe a
function safe(pred, x) {
  if(!(isFunction(pred) || isSameType(Pred, pred))) {
    throw new TypeError('safe: Pred or predicate function required for first argument')
  }

  return predOrFunc(pred, x)
    ? Just(x)
    : Nothing()
}

module.exports = curry(safe)


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _equals = __webpack_require__(16)
var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('List')

var isApplicative = __webpack_require__(13)
var isArray = __webpack_require__(7)
var isEmpty = __webpack_require__(33)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)
var isSemigroup = __webpack_require__(18)
var predOrFunc = __webpack_require__(17)

var not =
  function (fn) { return function (x) { return !fn(x); }; }

var _concat =
  function (x) { return function (m) { return m.concat(x); }; }

var ref = __webpack_require__(14);
var Nothing = ref.Nothing;
var Just = ref.Just;

var Pred = __webpack_require__(3).proxy('Pred')

var _of =
  function (x) { return List([ x ]); }

var _empty =
  function () { return List([]); }

function fromArray(xs) {
  if(!isArray(xs)) {
    throw new TypeError('List.fromArray: Array required')
  }
  return xs.reduce(function (res, x) { return res.concat(List.of(x)); }, List.empty())
}

function runSequence(acc, x) {
  if(!isApplicative(x)) {
    throw new TypeError('List.sequence: Must wrap Applicatives')
  }

  return x
    .map(function (v) { return _concat(List.of(v)); })
    .ap(acc)
}

function runTraverse(f) {
  return function(acc, x) {
    var m = f(x)

    if(!isApplicative(acc) || !isApplicative(m)) {
      throw new TypeError('List.traverse: Both functions must return an Applicative')
    }

    return m
      .map(function (v) { return _concat(List.of(v)); })
      .ap(acc)
  }
}

function List(x) {
  if(!arguments.length) {
    throw new TypeError('List: List must wrap something')
  }

  var xs = isArray(x) ? x.slice() : [ x ]

  function flatMap(fn) {
    return function(y, x) {
      var m = fn(x)

      if(!isSameType(List, m)) {
        throw new TypeError('List.chain: Function must return a List')
      }

      return y.concat(m.valueOf())
    }
  }

  var of =
    _of

  var valueOf =
    function () { return xs.slice(); }

  var toArray =
    valueOf

  var empty =
    _empty

  var inspect =
    function () { return ("List" + (_inspect(xs))); }

  var head =
    function () { return xs.length
      ? Just(xs[0])
      : Nothing(); }

  var tail =
    function () { return xs.length && xs.length > 1
      ? Just(List(xs.slice(1)))
      : Nothing(); }

  var cons =
    function (x) { return List([ x ].concat(xs)); }

  var equals = function (m) { return isSameType(List, m)
      && _equals(xs, m.valueOf()); }

  function concat(m) {
    if(!isSameType(List, m)) {
      throw new TypeError('List.concat: List required')
    }

    return List(xs.concat(m.valueOf()))
  }

  function reduce(fn, i) {
    if(!isFunction(fn)) {
      throw new TypeError('List.reduce: Function required for first argument')
    }

    return xs.reduce(fn, i)
  }

  function fold() {
    if(isEmpty(xs)) {
      throw new TypeError('List.fold: List must contain at least one Semigroup')
    }
    if(xs.length === 1) {
      if(!isSemigroup(xs[0])) {
        throw new TypeError('List.fold: List must contain Semigroups of the same type')
      }
      return xs[0]
    }
    return xs.reduce(function(x, y) {
      if(!(isSemigroup(x) && isSameType(x, y))) {
        throw new TypeError('List.fold: List must contain Semigroups of the same type')
      }
      return x.concat(y)
    })
  }

  function filter(pred) {
    if(!(isFunction(pred) || isSameType(Pred, pred))) {
      throw new TypeError('List.filter: Pred or predicate function required')
    }

    return reduce(
      function (x, y) { return predOrFunc(pred, y) ? x.concat(x.of(y)) : x; },
      empty()
    )
  }

  function reject(pred) {
    if(!(isFunction(pred) || isSameType(Pred, pred))) {
      throw new TypeError('List.reject: Pred or predicate function required')
    }

    var fn = not(function (x) { return predOrFunc(pred, x); })

    return reduce(
      function (x, y) { return fn(y) ? x.concat(x.of(y)) : x; },
      empty()
    )
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('List.map: Function required')
    }

    return List(xs.map(function (x) { return fn(x); }))
  }

  function ap(m) {
    var allFuncs =
      xs.reduce(function (b, i) { return b && isFunction(i); }, true)

    if(!allFuncs) {
      throw new TypeError('List.ap: Wrapped values must all be functions')
    }
    else if(!isSameType(List, m)) {
      throw new TypeError('List.ap: List required')
    }

    return chain(function (fn) { return m.map(fn); })
  }

  function chain(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('List.chain: Function required')
    }

    return List(xs.reduce(flatMap(fn), []))
  }

  function sequence(af) {
    if(!isFunction(af)) {
      throw new TypeError('List.sequence: Applicative Function required')
    }

    return reduce(
      runSequence,
      af(List.empty())
    )
  }

  function traverse(af, f) {
    if(!isFunction(f) || !isFunction(af)) {
      throw new TypeError('List.traverse: Applicative returning functions required for both arguments')
    }

    return reduce(
      runTraverse(f),
      af(List.empty())
    )
  }

  return {
    inspect: inspect, valueOf: valueOf, toArray: toArray, head: head, tail: tail, cons: cons,
    type: type, equals: equals, concat: concat, empty: empty, reduce: reduce, fold: fold,
    filter: filter, reject: reject, map: map, ap: ap, of: of, chain: chain,
    sequence: sequence, traverse: traverse
  }
}

List.type =
  type

List.of =
  _of

List.empty =
  _empty

List.fromArray =
  fromArray

List['@@implements'] = _implements(
  [ 'ap', 'chain', 'concat', 'empty', 'equals', 'map', 'of', 'reduce', 'traverse' ]
)

module.exports = List


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var type = __webpack_require__(3).type('Unit')

var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var _of =
  Unit

var _empty =
  Unit

function Unit() {
  var equals =
    function (m) { return isSameType(Unit, m); }

  var inspect =
    function () { return '()'; }

  var valueOf =
    function () { return undefined; }

  var of =
    _of

  var empty =
    _empty

  function concat(m) {
    if(!(isSameType(Unit, m))) {
      throw new TypeError('Unit.concat: Unit required')
    }

    return Unit()
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Unit.map: Function required')
    }

    return Unit()
  }

  function ap(m) {
    if(!isSameType(Unit, m)) {
      throw new TypeError('Unit.ap: Unit required')
    }

    return Unit()
  }

  function chain(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Unit.chain: Function required')
    }

    return Unit()
  }

  return {
    inspect: inspect, valueOf: valueOf, type: type, equals: equals,
    concat: concat, empty: empty, map: map, ap: ap, of: of, chain: chain
  }
}

Unit.type = type
Unit.of = _of
Unit.empty = _empty

Unit['@@implements'] = _implements(
  [ 'ap', 'chain', 'concat', 'empty', 'equals', 'map', 'of' ]
)

module.exports = Unit


/***/ }),
/* 46 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  Function.prototype


/***/ }),
/* 47 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

function curryN(n, fn) {
  return function() {
    var xs = [], len = arguments.length;
    while ( len-- ) xs[ len ] = arguments[ len ];

    var args =
      xs.length ? xs : [ undefined ]

    var remaining =
       Math.floor(n) - args.length

    return (remaining > 0)
      ? curryN(remaining, Function.bind.apply(fn, [ null ].concat(args)))
      : fn.apply(null, args.slice(0, n))
  }
}

module.exports = curryN


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isFunctor = __webpack_require__(20)

// isExtend : a -> Boolean
function isExtend(m) {
  return isFunctor(m)
    && hasAlg('extend', m)
}

module.exports = isExtend


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isApplicative = __webpack_require__(13)

// isMonad : a -> Boolean
function isMonad(m) {
  return isApplicative(m)
    && hasAlg('chain', m)
}

module.exports = isMonad



/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isAlt = __webpack_require__(40)

// isPlus : a -> Boolean
function isPlus(m) {
  return isAlt(m)
    && hasAlg('zero', m)
}

module.exports = isPlus


/***/ }),
/* 51 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// isSame : (a, b) -> Boolean
function isSame(x, y) {
  if(x === y) {
    return x !== 0 || 1 / x === 1 / y
  }

  return x !== x && y !== y
}

module.exports = isSame


/***/ }),
/* 52 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// once : ((*) -> b) -> ((*) -> b)
function once(fn) {
  var called, result

  return function() {
    if(!called) {
      called = true
      result = fn.apply(null, arguments)
    }

    return result
  }
}

module.exports = once


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

function type(x) {
  if(x) {
    if(isFunction(x.type)) {
      return x.type()
    }
  }
  return ({}).toString.call(x).slice(8, -1)
}

module.exports = type


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('All')

var isFunction = __webpack_require__(0)
var isNil = __webpack_require__(11)
var isSameType = __webpack_require__(2)

var _empty =
  function () { return All(true); }

function All(b) {
  var x = isNil(b) ? _empty().valueOf() : b

  if(!arguments.length || isFunction(x)) {
    throw new TypeError('All: Non-function value required')
  }

  var valueOf =
    function () { return !!x; }

  var empty =
    _empty

  var inspect =
    function () { return ("All" + (_inspect(valueOf()))); }

  function concat(m) {
    if(!isSameType(All, m)) {
      throw new TypeError('All.concat: All required')
    }

    return All(m.valueOf() && valueOf())
  }

  return { inspect: inspect, valueOf: valueOf, type: type, concat: concat, empty: empty }
}

All['@@implements'] = _implements(
  [ 'concat', 'empty' ]
)

All.empty =
  _empty

All.type =
  type

module.exports = All


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Any')

var isFunction = __webpack_require__(0)
var isNil = __webpack_require__(11)
var isSameType = __webpack_require__(2)

var _empty =
  function () { return Any(false); }

function Any(b) {
  var x = isNil(b) ? _empty().valueOf() : b

  if(!arguments.length || isFunction(x)) {
    throw new TypeError('Any: Non-function value required')
  }

  var valueOf =
    function () { return !!x; }

  var empty =
    _empty

  var inspect =
    function () { return ("Any" + (_inspect(valueOf()))); }

  function concat(m) {
    if(!isSameType(Any, m)) {
      throw new TypeError('Any.concat: Any required')
    }

    return Any(m.valueOf() || valueOf())
  }

  return { inspect: inspect, valueOf: valueOf, type: type, concat: concat, empty: empty }
}

Any['@@implements'] = _implements(
  [ 'concat', 'empty' ]
)

Any.empty = _empty
Any.type  = type

module.exports = Any


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Arrow')

var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var Pair = __webpack_require__(3).proxy('Pair')

var _id =
  function () { return Arrow(function (x) { return x; }); }

function Arrow(runWith) {
  if(!isFunction(runWith)) {
    throw new TypeError('Arrow: Function required')
  }

  var inspect =
    function () { return ("Arrow" + (_inspect(runWith))); }

  var id =
    _id

  function compose(m) {
    if(!(isSameType(Arrow, m))) {
      throw new TypeError('Arrow.compose: Arrow required')
    }

    return map(m.runWith)
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Arrow.map: Function required')
    }

    return Arrow(function (x) { return fn(runWith(x)); })
  }

  function contramap(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Arrow.contramap: Function required')
    }

    return Arrow(function (x) { return runWith(fn(x)); })
  }

  function promap(l, r) {
    if(!isFunction(l) || !isFunction(r)) {
      throw new TypeError('Arrow.promap: Functions required for both arguments')
    }

    return Arrow(function (x) { return r(runWith(l(x))); })
  }

  function first() {
    return Arrow(function(x) {
      if(!(isSameType(Pair, x))) {
        throw TypeError('Arrow.first: Pair required for inner argument')
      }
      return x.bimap(runWith, function (x) { return x; })
    })
  }

  function second() {
    return Arrow(function(x) {
      if(!(isSameType(Pair, x))) {
        throw TypeError('Arrow.second: Pair required for inner argument')
      }

      return x.bimap(function (x) { return x; }, runWith)
    })
  }

  function both() {
    return Arrow(function(x) {
      if(!(isSameType(Pair, x))) {
        throw TypeError('Arrow.both: Pair required for inner argument')
      }
      return x.bimap(runWith, runWith)
    })
  }

  return {
    inspect: inspect, type: type, runWith: runWith,
    id: id, compose: compose, map: map, contramap: contramap,
    promap: promap, first: first, second: second, both: both
  }
}

Arrow.id = _id
Arrow.type = type

Arrow['@@implements'] = _implements(
  [ 'compose', 'contramap', 'id', 'map', 'promap' ]
)

module.exports = Arrow


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var _object = __webpack_require__(22)
var type = __webpack_require__(3).type('Assign')

var isNil = __webpack_require__(11)
var isObject = __webpack_require__(8)
var isSameType = __webpack_require__(2)

var _empty =
  function () { return Assign({}); }

function Assign(o) {
  var x = isNil(o) ? _empty().valueOf() : o

  if(!arguments.length || !isObject(x)) {
    throw new TypeError('Assign: Object required')
  }

  var valueOf =
    function () { return x; }

  var empty =
    _empty

  var inspect =
    function () { return ("Assign" + (_inspect(valueOf()))); }

  function concat(m) {
    if(!isSameType(Assign, m)) {
      throw new TypeError('Assign.concat: Assign required')
    }

    return Assign(_object.assign(m.valueOf(), x))
  }

  return { inspect: inspect, valueOf: valueOf, type: type, concat: concat, empty: empty }
}

Assign['@@implements'] = _implements(
  [ 'concat', 'empty' ]
)

Assign.empty =
  _empty

Assign.type =
  type

module.exports = Assign


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Async = __webpack_require__(23)
var Either = __webpack_require__(3).proxy('Either')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (either) { return either.either(Async.Rejected, Async.Resolved); }

// eitherToAsync : Either e a -> Async e a
// eitherToAsync : (a -> Either e b) -> a -> Async e b
function eitherToAsync(either) {
  if(isFunction(either)) {
    return function(x) {
      var m = either(x)

      if(!isSameType(Either, m)) {
        throw new TypeError('eitherToAsync: Either returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Either, either)) {
    return applyTransform(either)
  }

  throw new TypeError('eitherToAsync: Either or Either returing function required')
}

module.exports = curry(eitherToAsync)


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Async = __webpack_require__(23)
var First = __webpack_require__(3).proxy('First')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

var applyTransform = function (left, first) { return first.valueOf().either(
    constant(Async.Rejected(left)),
    Async.Resolved
  ); }

// firstToAsync : e -> First a -> Async e a
// firstToAsync : e -> (a -> First b) -> a -> Async e b
function firstToAsync(left, first) {
  if(isFunction(first)) {
    return function(x) {
      var m = first(x)

      if(!isSameType(First, m)) {
        throw new TypeError('firstToAsync: First returing function required for second argument')
      }

      return applyTransform(left, m)
    }
  }

  if(isSameType(First, first)) {
    return applyTransform(left, first)
  }

  throw new TypeError('firstToAsync: First or First returing function required for second argument')
}

module.exports = curry(firstToAsync)


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Async = __webpack_require__(23)
var Last = __webpack_require__(3).proxy('Last')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

var applyTransform = function (left, last) { return last.valueOf().either(
    constant(Async.Rejected(left)),
    Async.Resolved
  ); }

// lastToAsync : e -> Last a -> Async e a
// lastToAsync : e -> (a -> Last b) -> a -> Async e b
function lastToAsync(left, last) {
  if(isFunction(last)) {
    return function(x) {
      var m = last(x)

      if(!isSameType(Last, m)) {
        throw new TypeError('lastToAsync: Last returing function required for second argument')
      }

      return applyTransform(left, m)
    }
  }

  if(isSameType(Last, last)) {
    return applyTransform(left, last)
  }

  throw new TypeError('lastToAsync: Last or Last returing function required for second argument')
}

module.exports = curry(lastToAsync)


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Async = __webpack_require__(23)
var Maybe = __webpack_require__(3).proxy('Maybe')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

var applyTransform = function (left, maybe) { return maybe.either(
    constant(Async.Rejected(left)),
    Async.Resolved
  ); }

// maybeToAsync : e -> Maybe a -> Async e a
// maybeToAsync : e -> (a -> Maybe b) -> a -> Async e b
function maybeToAsync(left, maybe) {
  if(isFunction(maybe)) {
    return function(x) {
      var m = maybe(x)

      if(!isSameType(Maybe, m)) {
        throw new TypeError('maybeToAsync: Maybe returing function required for second argument')
      }

      return applyTransform(left, m)
    }
  }

  if(isSameType(Maybe, maybe)) {
    return applyTransform(left, maybe)
  }

  throw new TypeError('maybeToAsync: Maybe or Maybe returing function required for second argument')
}

module.exports = curry(maybeToAsync)


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Async = __webpack_require__(23)
var Result = __webpack_require__(3).proxy('Result')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (either) { return either.either(Async.Rejected, Async.Resolved); }

// resultToAsync : Result e a -> Async e a
// resultToAsync : (a -> Result e b) -> a -> Async e b
function resultToAsync(result) {
  if(isFunction(result)) {
    return function(x) {
      var m = result(x)

      if(!isSameType(Result, m)) {
        throw new TypeError('resultToAsync: Result returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Result, result)) {
    return applyTransform(result)
  }

  throw new TypeError('resultToAsync: Result or Result returing function required')
}

module.exports = curry(resultToAsync)


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _equals = __webpack_require__(16)
var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Const')

var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

function Const(x) {
  if(!arguments.length) {
    throw new TypeError('Const: Must wrap something')
  }

  var equals =
    function (m) { return isSameType(Const, m)
      && _equals(x, m.valueOf()); }

  var inspect =
    function () { return ("Const" + (_inspect(x))); }

  var valueOf =
    function () { return x; }

  function concat(m) {
    if(!isSameType(Const, m)) {
      throw new TypeError('Const.concat: Const required')
    }

    return Const(x)
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Const.map: Function required')
    }

    return Const(x)
  }

  function ap(m) {
    if(!isSameType(Const, m)) {
      throw new TypeError('Const.ap: Const required')
    }

    return Const(x)
  }

  function chain(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Const.chain: Function required')
    }

    return Const(x)
  }

  return {
    inspect: inspect, valueOf: valueOf, type: type, equals: equals,
    concat: concat, map: map, ap: ap, chain: chain
  }
}
Const.type =
  type

Const['@@implements'] = _implements(
  [ 'ap', 'chain', 'concat', 'equals', 'map' ]
)

module.exports = Const


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Either = __webpack_require__(26)
var First = __webpack_require__(3).proxy('First')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

var applyTransform = function (left, first) { return first.valueOf().either(
    constant(Either.Left(left)),
    Either.Right
  ); }

// firstToEither : c -> First a -> Either c a
// firstToEither : c -> (a -> First b) -> a -> Either c b
function firstToEither(left, first) {
  if(isFunction(first)) {
    return function(x) {
      var m = first(x)

      if(!isSameType(First, m)) {
        throw new TypeError('firstToEither: First returing function required for second argument')
      }

      return applyTransform(left, m)
    }
  }

  if(isSameType(First, first)) {
    return applyTransform(left, first)
  }

  throw new TypeError('firstToEither: First or First returing function required for second argument')
}

module.exports = curry(firstToEither)


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Either = __webpack_require__(26)
var Last = __webpack_require__(3).proxy('Last')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

var applyTransform = function (left, last) { return last.valueOf().either(
    constant(Either.Left(left)),
    Either.Right
  ); }

// lastToEither : c -> Last a -> Either c a
// lastToEither : c -> (a -> Last b) -> a -> Either c b
function lastToEither(left, last) {
  if(isFunction(last)) {
    return function(x) {
      var m = last(x)

      if(!isSameType(Last, m)) {
        throw new TypeError('lastToEither: Last returing function required for second argument')
      }

      return applyTransform(left, m)
    }
  }

  if(isSameType(Last, last)) {
    return applyTransform(left, last)
  }

  throw new TypeError('lastToEither: Last or Last returing function required for second argument')
}

module.exports = curry(lastToEither)


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Either = __webpack_require__(26)
var Maybe = __webpack_require__(3).proxy('Maybe')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

var applyTransform = function (left, maybe) { return maybe.either(
    constant(Either.Left(left)),
    Either.Right
  ); }

// maybeToEither : c -> Maybe a -> Either c a
// maybeToEither : c -> (a -> Maybe b) -> a -> Either c b
function maybeToEither(left, maybe) {
  if(isFunction(maybe)) {
    return function(x) {
      var m = maybe(x)

      if(!isSameType(Maybe, m)) {
        throw new TypeError('maybeToEither: Maybe returing function required for second argument')
      }

      return applyTransform(left, m)
    }
  }

  if(isSameType(Maybe, maybe)) {
    return applyTransform(left, maybe)
  }

  throw new TypeError('maybeToEither: Maybe or Maybe returing function required for second argument')
}

module.exports = curry(maybeToEither)


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Either = __webpack_require__(26)
var Result = __webpack_require__(3).proxy('Result')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (result) { return result.either(Either.Left, Either.Right); }

// resultToEither : Result e a -> Either e a
// resultToEither : (a -> Result e b) -> a -> Either e b
function resultToEither(result) {
  if(isFunction(result)) {
    return function(x) {
      var m = result(x)

      if(!isSameType(Result, m)) {
        throw new TypeError('resultToEither: Result returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Result, result)) {
    return applyTransform(result)
  }

  throw new TypeError('resultToEither: Result or Result returing function required')
}

module.exports = curry(resultToEither)


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Endo')

var compose = __webpack_require__(9)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var _empty =
  function () { return Endo(function (x) { return x; }); }

function Endo(runWith) {
  if(!isFunction(runWith)) {
    throw new TypeError('Endo: Function value required')
  }

  var valueOf =
    function () { return runWith; }

  var empty =
    _empty

  var inspect =
    function () { return ("Endo" + (_inspect(valueOf()))); }

  function concat(m) {
    if(!isSameType(Endo, m)) {
      throw new TypeError('Endo.concat: Endo required')
    }

    return Endo(compose(m.valueOf(), valueOf()))
  }

  return { inspect: inspect, valueOf: valueOf, type: type, concat: concat, empty: empty, runWith: runWith }
}

Endo['@@implements'] = _implements(
  [ 'concat', 'empty' ]
)

Endo.empty = _empty
Endo.type = type

module.exports = Endo



/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var First = __webpack_require__(27)
var Either = __webpack_require__(3).proxy('Either')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (either) { return either.either(First.empty, First); }

// eitherToFirst : Either b a -> First a
// eitherToFirst : (a -> Either c b) -> a -> First b
function eitherToFirst(either) {
  if(isFunction(either)) {
    return function(x) {
      var m = either(x)

      if(!isSameType(Either, m)) {
        throw new TypeError('eitherToFirst: Either returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Either, either)) {
    return applyTransform(either)
  }

  throw new TypeError('eitherToFirst: Either or Either returing function required')
}

module.exports = curry(eitherToFirst)


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var First = __webpack_require__(27)
var Last = __webpack_require__(3).proxy('Last')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (last) { return First(last.valueOf()); }

// lastToFirst : Last a -> First a
// lastToFirst : (a -> Last b) -> a -> First b
function lastToFirst(last) {
  if(isFunction(last)) {
    return function(x) {
      var m = last(x)

      if(!isSameType(Last, m)) {
        throw new TypeError('lastToFirst: Last returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Last, last)) {
    return applyTransform(last)
  }

  throw new TypeError('lastToFirst: Last or Last returing function required')
}

module.exports = curry(lastToFirst)


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var First = __webpack_require__(27)
var Maybe = __webpack_require__(3).proxy('Maybe')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (maybe) { return First(maybe); }

// maybeToFirst : Maybe a -> First a
// maybeToFirst : (a -> Maybe b) -> a -> First b
function maybeToFirst(maybe) {
  if(isFunction(maybe)) {
    return function(x) {
      var m = maybe(x)

      if(!isSameType(Maybe, m)) {
        throw new TypeError('maybeToFirst: Maybe returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Maybe, maybe)) {
    return applyTransform(maybe)
  }

  throw new TypeError('maybeToFirst: Maybe or Maybe returing function required')
}

module.exports = curry(maybeToFirst)


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var First = __webpack_require__(27)
var Result = __webpack_require__(3).proxy('Result')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (result) { return result.either(First.empty, First); }

// resultToFirst : Result b a -> First a
// resultToFirst : (a -> Result c b) -> a -> First b
function resultToFirst(result) {
  if(isFunction(result)) {
    return function(x) {
      var m = result(x)

      if(!isSameType(Result, m)) {
        throw new TypeError('resultToFirst: Result returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Result, result)) {
    return applyTransform(result)
  }

  throw new TypeError('resultToFirst: Result or Result returing function required')
}

module.exports = curry(resultToFirst)


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('IO')

var compose = __webpack_require__(9)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var _of =
  function (x) { return IO(function () { return x; }); }

function IO(run) {
  if(!isFunction(run)) {
    throw new TypeError('IO: Must wrap a function')
  }

  var of =
    _of

  var inspect =
    function () { return ("IO" + (_inspect(run))); }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('IO.map: Function required')
    }

    return IO(compose(fn, run))
  }

  function ap(m) {
    if(!isSameType(IO, m)) {
      throw new TypeError('IO.ap: IO required')
    }

    return chain(function (f) { return m.map(f); })
  }

  function chain(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('IO.chain: Function required')
    }

    return IO(function() {
      var m = fn(run())

      if(!isSameType(IO, m)) {
        throw new TypeError('IO.chain: Function must return an IO')
      }

      return m.run()
    })
  }

  return {
    inspect: inspect, run: run, type: type,
    map: map, ap: ap, of: of, chain: chain
  }
}

IO.of = _of
IO.type = type

IO['@@implements'] = _implements(
  [ 'ap', 'chain', 'map', 'of' ]
)

module.exports = IO


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _equals = __webpack_require__(16)
var _implements = __webpack_require__(4)
var _innerConcat = __webpack_require__(31)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Identity')

var isApplicative = __webpack_require__(13)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var _of =
  Identity

function Identity(x) {
  if(!arguments.length) {
    throw new TypeError('Identity: Must wrap something')
  }

  var valueOf =
    function () { return x; }

  var of =
    _of

  var equals =
    function (m) { return isSameType(Identity, m)
      && _equals(x, m.valueOf()); }

  var inspect =
    function () { return ("Identity" + (_inspect(x))); }

  function concat(m) {
    if(!isSameType(Identity, m)) {
      throw new TypeError('Identity.concat: Identity of Semigroup required')
    }

    return _innerConcat(Identity, m)(x)
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Identity.map: Function required')
    }

    return Identity(fn(x))
  }

  function ap(m) {
    if(!isFunction(x)) {
      throw new TypeError('Identity.ap: Wrapped value must be a function')
    }
    else if(!isSameType(Identity, m)) {
      throw new TypeError('Identity.ap: Identity required')
    }

    return m.map(x)
  }

  function chain(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Identity.chain: Function required')
    }

    var m = fn(x)

    if(!isSameType(Identity, m)) {
      throw new TypeError('Identity.chain: Function must return an Identity')
    }

    return m
  }

  function sequence(af) {
    if(!isFunction(af)) {
      throw new TypeError('Identity.sequence: Applicative Function required')
    }
    else if(!isApplicative(x)) {
      throw new TypeError('Identity.sequence: Must wrap an Applicative')
    }

    return x.map(Identity)
  }

  function traverse(af, f) {
    if(!isFunction(f) || !isFunction(af)) {
      throw new TypeError('Identity.traverse: Applicative returning functions required for both arguments')
    }

    var m = f(x)

    if(!isApplicative(m)) {
      throw new TypeError('Identity.traverse: Both functions must return an Applicative')
    }

    return m.map(Identity)
  }

  return {
    inspect: inspect, valueOf: valueOf, type: type, equals: equals,
    concat: concat, map: map, ap: ap, of: of, chain: chain,
    sequence: sequence, traverse: traverse
  }
}

Identity.of = _of
Identity.type = type

Identity['@@implements'] = _implements(
  [ 'ap', 'chain', 'concat', 'equals', 'map', 'of', 'traverse' ]
)

module.exports = Identity


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Last = __webpack_require__(28)
var Either = __webpack_require__(3).proxy('Either')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (either) { return either.either(Last.empty, Last); }

// eitherToLast : Either b a -> Last a
// eitherToLast : (a -> Either c b) -> a -> Last b
function eitherToLast(either) {
  if(isFunction(either)) {
    return function(x) {
      var m = either(x)

      if(!isSameType(Either, m)) {
        throw new TypeError('eitherToLast: Either returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Either, either)) {
    return applyTransform(either)
  }

  throw new TypeError('eitherToLast: Either or Either returing function required')
}

module.exports = curry(eitherToLast)


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Last = __webpack_require__(28)
var First = __webpack_require__(3).proxy('First')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (first) { return Last(first.valueOf()); }

// firstToLast : First a -> Last a
// firstToLast : (a -> First b) -> a -> Last b
function firstToLast(first) {
  if(isFunction(first)) {
    return function(x) {
      var m = first(x)

      if(!isSameType(First, m)) {
        throw new TypeError('firstToLast: First returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(First, first)) {
    return applyTransform(first)
  }

  throw new TypeError('firstToLast: First or First returing function required')
}

module.exports = curry(firstToLast)


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Last = __webpack_require__(28)
var Maybe = __webpack_require__(3).proxy('Maybe')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (maybe) { return Last(maybe); }

// maybeToLast : Maybe a -> Last a
// maybeToLast : (a -> Maybe b) -> a -> Last b
function maybeToLast(maybe) {
  if(isFunction(maybe)) {
    return function(x) {
      var m = maybe(x)

      if(!isSameType(Maybe, m)) {
        throw new TypeError('maybeToLast: Maybe returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Maybe, maybe)) {
    return applyTransform(maybe)
  }

  throw new TypeError('maybeToLast: Maybe or Maybe returing function required')
}

module.exports = curry(maybeToLast)


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Last = __webpack_require__(28)
var Result = __webpack_require__(3).proxy('Result')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (result) { return result.either(Last.empty, Last); }

// resultToLast : Result b a -> Last a
// resultToLast : (a -> Result c b) -> a -> Last b
function resultToLast(result) {
  if(isFunction(result)) {
    return function(x) {
      var m = result(x)

      if(!isSameType(Result, m)) {
        throw new TypeError('resultToLast: Result returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Result, result)) {
    return applyTransform(result)
  }

  throw new TypeError('resultToLast: Result or Result returing function required')
}

module.exports = curry(resultToLast)


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var List = __webpack_require__(37)

var curry = __webpack_require__(1)
var isArray = __webpack_require__(7)
var isFunction = __webpack_require__(0)

// arrayToList : [ a ] -> List a
// arrayToList : (a -> [ b ]) -> a -> List b
function arrayToList(array) {
  if(isArray(array)) {
    return List.fromArray(array)
  }
  else if(isFunction(array)) {
    return function(x) {
      var g = array(x)

      if(!isArray(g)) {
        throw new TypeError('arrayToList: Array returing function required')
      }

      return List.fromArray(g)
    }
  }

  throw new TypeError('arrayToList: Array or Array returing function required')
}

module.exports = curry(arrayToList)


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var List = __webpack_require__(37)

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

// listToArray : List a -> [ a ]
// listToArray : (a -> List b) -> a -> [ b ]
function listToArray(list) {
  if(isFunction(list)) {
    return function(x) {
      var m = list(x)

      if(!isSameType(List, m)) {
        throw new TypeError('listToArray: List returing function required')
      }

      return m.toArray()
    }
  }

  if(isSameType(List, list)) {
    return list.toArray()
  }

  throw new TypeError('listToArray: List or List returing function required')
}

module.exports = curry(listToArray)


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Max')

var isNil = __webpack_require__(11)
var isNumber = __webpack_require__(21)
var isSameType = __webpack_require__(2)

var _empty =
  function () { return Max(-Infinity); }

function Max(n) {
  var x = isNil(n) ? _empty().valueOf() : n

  if(!arguments.length || !isNumber(x)) {
    throw new TypeError('Max: Numeric value required')
  }

  var valueOf =
    function () { return x; }

  var empty =
    _empty

  var inspect =
    function () { return ("Max" + (_inspect(valueOf()))); }

  function concat(m) {
    if(!isSameType(Max, m)) {
      throw new TypeError('Max.concat: Max requried')
    }

    return Max(Math.max(x, m.valueOf()))
  }

  return { inspect: inspect, valueOf: valueOf, type: type, concat: concat, empty: empty }
}

Max['@@implements'] = _implements(
  [ 'concat', 'empty' ]
)

Max.empty = _empty
Max.type = type

module.exports = Max


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Maybe = __webpack_require__(38)
var Either = __webpack_require__(3).proxy('Either')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (either) { return either.either(Maybe.Nothing, Maybe.Just); }

// eitherToMaybe : Either b a -> Maybe a
// eitherToMaybe : (a -> Either c b) -> a -> Maybe b
function eitherToMaybe(either) {
  if(isFunction(either)) {
    return function(x) {
      var m = either(x)

      if(!isSameType(Either, m)) {
        throw new TypeError('eitherToMaybe: Either returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Either, either)) {
    return applyTransform(either)
  }

  throw new TypeError('eitherToMaybe: Either or Either returing function required')
}

module.exports = curry(eitherToMaybe)


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var First = __webpack_require__(3).proxy('First')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (first) { return first.valueOf(); }

// firstToMaybe : First a -> Maybe a
// firstToMaybe : (a -> First b) -> a -> Maybe b
function firstToMaybe(first) {
  if(isFunction(first)) {
    return function(x) {
      var m = first(x)

      if(!isSameType(First, m)) {
        throw new TypeError('firstToMaybe: First returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(First, first)) {
    return applyTransform(first)
  }

  throw new TypeError('firstToMaybe: First or First returing function required')
}

module.exports = curry(firstToMaybe)


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Last = __webpack_require__(3).proxy('Last')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (last) { return last.valueOf(); }

// lastToMaybe : Last a -> Maybe a
// lastToMaybe : (a -> Last b) -> a -> Maybe b
function lastToMaybe(last) {
  if(isFunction(last)) {
    return function(x) {
      var m = last(x)

      if(!isSameType(Last, m)) {
        throw new TypeError('lastToMaybe: Last returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Last, last)) {
    return applyTransform(last)
  }

  throw new TypeError('lastToMaybe: Last or Last returing function required')
}

module.exports = curry(lastToMaybe)


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isDefined = __webpack_require__(42)
var isNil= __webpack_require__(11)
var isInteger = __webpack_require__(34)
var isString = __webpack_require__(10)
var ref = __webpack_require__(14);
var Nothing = ref.Nothing;
var Just = ref.Just;

var lift = function (x) { return isDefined(x) ? Just(x) : Nothing(); }

// prop : String | Number -> a -> Maybe b
function prop(key, target) {
  if(!(isString(key) || isInteger(key))) {
    throw new TypeError('prop: String or integer required for first argument')
  }

  if(isNil(target)) {
    return Nothing()
  }

  return lift(target[key])
}

module.exports = curry(prop)


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Maybe = __webpack_require__(14)
var Nothing = Maybe.Nothing;
var Just = Maybe.Just;

var curry = __webpack_require__(1)
var isArray = __webpack_require__(7)
var isDefined = __webpack_require__(42)
var isInteger = __webpack_require__(34)
var isNil= __webpack_require__(11)
var isString = __webpack_require__(10)

var lift = function (x) { return isDefined(x) ? Just(x) : Nothing(); }

// propPath : [ String | Number ] -> a -> Maybe b
function propPath(keys, target) {
  if(!isArray(keys)) {
    throw new TypeError('propPath: Array of strings or integers required for first argument')
  }

  if(isNil(target)) {
    return Nothing()
  }
  return keys.reduce(function (maybe, key) {
    if(!(isString(key) || isInteger(key))) {
      throw new TypeError('propPath: Array of strings or integers required for first argument')
    }
    return maybe.chain(function (x) { return lift(x[key]); })
  }, Maybe.of(target))
}

module.exports = curry(propPath)


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Maybe = __webpack_require__(38)
var Result = __webpack_require__(3).proxy('Result')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (result) { return result.either(Maybe.Nothing, Maybe.Just); }

// resultToMaybe : Result b a -> Maybe a
// resultToMaybe : (a -> Result c b) -> a -> Maybe b
function resultToMaybe(result) {
  if(isFunction(result)) {
    return function(x) {
      var m = result(x)

      if(!isSameType(Result, m)) {
        throw new TypeError('resultToMaybe: Result returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Result, result)) {
    return applyTransform(result)
  }

  throw new TypeError('resultToMaybe: Result or Result returing function required')
}

module.exports = curry(resultToMaybe)


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pred = __webpack_require__(3).proxy('Pred')

var compose = __webpack_require__(9)
var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)
var safe = __webpack_require__(43)

var map =
  function (fn) { return function (m) { return m.map(fn); }; }

// safeLift : ((a -> Boolean) | Pred) -> (a -> b) -> a -> Maybe b
function safeLift(pred, fn) {
  if(!(isFunction(pred) || isSameType(Pred, pred))) {
    throw new TypeError('safeLift: Pred or predicate function required for first argument')
  }
  else if(!isFunction(fn)) {
    throw new TypeError('safeLift: Function required for second argument')
  }

  return compose(map(fn), safe(pred))
}

module.exports = curry(safeLift)


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Min')

var isNil = __webpack_require__(11)
var isNumber = __webpack_require__(21)
var isSameType = __webpack_require__(2)

var _empty =
  function () { return Min(Infinity); }

function Min(n) {
  var x = isNil(n) ? _empty().valueOf() : n

  if(!arguments.length || !isNumber(x)) {
    throw new TypeError('Min: Numeric value required')
  }

  var valueOf =
    function () { return x; }

  var empty =
    _empty

  var inspect =
    function () { return ("Min" + (_inspect(valueOf()))); }

  function concat(m) {
    if(!isSameType(Min, m)) {
      throw new TypeError('Min.concat: Min required')
    }

    return Min(Math.min(x, m.valueOf()))
  }

  return { inspect: inspect, valueOf: valueOf, type: type, concat: concat, empty: empty }
}

Min['@@implements'] = _implements(
  [ 'concat', 'empty' ]
)

Min.empty = _empty
Min.type = type

module.exports = Min


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pair = __webpack_require__(19)

// branch : a -> Pair a a
function branch(x) {
  return Pair(x, x)
}

module.exports = branch


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

function fst(m) {
  if(!(m && isFunction(m.fst))) {
    throw new TypeError('fst: Pair required')
  }

  return m.fst()
}

module.exports = fst


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(19)


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function merge(fn, m) {
  if(!isFunction(fn)) {
    throw new TypeError('merge: Binary function required for first argument')
  }

  if(!(m && isFunction(m.merge))) {
    throw new TypeError('merge: Pair required for second argument')
  }

  return m.merge(fn)
}

module.exports = curry(merge)


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

function snd(m) {
  if(!(m && isFunction(m.snd))) {
    throw new TypeError('snd: Pair required')
  }

  return m.snd()
}

module.exports = snd


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var List = __webpack_require__(44)
var Pair = __webpack_require__(19)
var isObject = __webpack_require__(8)

// toPairs : Object -> List (Pair String a)
function toPairs(obj) {
  if(!isObject(obj)) {
    throw new TypeError('toPairs: Object required for argument')
  }

  return Object.keys(obj).reduce(
    function (acc, key) { return obj[key] !== undefined
      ? acc.concat(List.of(Pair(key, obj[key])))
      : acc; },
    List.empty()
  )
}

module.exports = toPairs


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

var isWriter =
  function (x) { return !!x && isFunction(x.read); }

var applyTransform = function (w) { return w.read(); }

// writerToPair : Monoid m => Writer m a -> Pair m a
// writerToPair : Monoid m => (a -> Writer m a) -> Pair m b
function writerToPair(writer) {
  if(isFunction(writer)) {
    return function(x) {
      var m = writer(x)

      if(!isWriter(m)) {
        throw new TypeError('writerToPair: Writer returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isWriter(writer)) {
    return applyTransform(writer)
  }

  throw new TypeError('writerToPair: Writer or Writer returing function required')
}

module.exports = curry(writerToPair)


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Pred')

var compose = __webpack_require__(9)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var _empty =
  function () { return Pred(function () { return true; }); }

function Pred(pred) {
  if(!isFunction(pred)) {
    throw new TypeError('Pred: Predicate function required')
  }

  var runWith =
    function (x) { return !!pred(x); }

  var inspect =
    function () { return ("Pred" + (_inspect(runWith))); }

  var empty =
    _empty

  var valueOf =
    function () { return runWith; }

  function concat(m) {
    if(!isSameType(Pred, m)) {
      throw new TypeError('Pred.concat: Pred required')
    }

    return Pred(function (x) { return !!runWith(x) && !!m.runWith(x); })
  }

  function contramap(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Pred.contramap: Function required')
    }

    return Pred(compose(runWith, fn))
  }

  return {
    runWith: runWith, inspect: inspect, type: type,
    valueOf: valueOf, empty: empty, concat: concat,
    contramap: contramap
  }
}

Pred.empty = _empty
Pred.type = type

Pred['@@implements'] = _implements(
  [ 'concat', 'contramap', 'empty' ]
)

module.exports = Pred


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Prod')

var isNil = __webpack_require__(11)
var isNumber = __webpack_require__(21)
var isSameType = __webpack_require__(2)

var _empty =
  function () { return Prod(1); }

function Prod(n) {
  var x = isNil(n) ? _empty().valueOf() : n

  if(!arguments.length || !isNumber(x)) {
    throw new TypeError('Prod: Numeric value required')
  }

  var valueOf =
    function () { return x; }

  var empty =
    _empty

  var inspect =
    function () { return ("Prod" + (_inspect(valueOf()))); }

  function concat(m) {
    if(!isSameType(Prod, m)) {
      throw new TypeError('Prod.concat: Prod required')
    }

    return Prod(x * m.valueOf())
  }

  return { inspect: inspect, valueOf: valueOf, type: type, concat: concat, empty: empty }
}

Prod['@@implements'] = _implements(
  [ 'concat', 'empty' ]
)

Prod.empty = _empty
Prod.type = type

module.exports = Prod


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Reader')

var compose = __webpack_require__(9)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var _of =
  function (x) { return Reader(function () { return x; }); }

function ask(fn) {
  if(!arguments.length) {
    return Reader(function (x) { return x; })
  }

  if(isFunction(fn)) {
    return Reader(fn)
  }

  throw new TypeError('Reader.ask: No argument or function required')
}

function Reader(runWith) {
  if(!arguments.length || !isFunction(runWith)) {
    throw new TypeError('Reader: Must wrap a function')
  }

  var of =
    _of

  var inspect =
    function () { return ("Reader" + (_inspect(runWith))); }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Reader.map: Function required')
    }

    return Reader(compose(fn, runWith))
  }

  function ap(m) {
    if(!isSameType(Reader, m)) {
      throw new TypeError('Reader.ap: Reader required')
    }

    return chain(function (f) { return m.map(f); })
  }

  function chain(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('Reader.chain: Function required')
    }

    return Reader(function(e) {
      var m = fn(runWith(e))

      if(!isSameType(Reader, m)) {
        throw new TypeError('Reader.chain: Function must return a Reader')
      }

      return m.runWith(e)
    })
  }

  return {
    inspect: inspect, runWith: runWith, type: type,
    map: map, ap: ap, chain: chain, of: of
  }
}

Reader.of = _of
Reader.type = type
Reader.ask = ask

Reader['@@implements'] = _implements(
  [ 'ap', 'chain', 'map', 'of' ]
)

module.exports = Reader


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Result = __webpack_require__(24)
var Either = __webpack_require__(3).proxy('Either')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var applyTransform = function (either) { return either.either(Result.Err, Result.Ok); }

// eitherToResult : Either e a -> Result e a
// eitherToResult : (a -> Either e b) -> a -> Result e b
function eitherToResult(either) {
  if(isFunction(either)) {
    return function(x) {
      var m = either(x)

      if(!isSameType(Either, m)) {
        throw new TypeError('eitherToResult: Either returing function required')
      }

      return applyTransform(m)
    }
  }

  if(isSameType(Either, either)) {
    return applyTransform(either)
  }

  throw new TypeError('eitherToResult: Either or Either returing function required')
}

module.exports = curry(eitherToResult)


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Result = __webpack_require__(24)
var First = __webpack_require__(3).proxy('First')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

var applyTransform = function (left, first) { return first.valueOf().either(
    constant(Result.Err(left)),
    Result.Ok
  ); }

// firstToResult : c -> First a -> Result c a
// firstToResult : c -> (a -> First b) -> a -> Result c b
function firstToResult(left, first) {
  if(isFunction(first)) {
    return function(x) {
      var m = first(x)

      if(!isSameType(First, m)) {
        throw new TypeError('firstToResult: First returing function required for second argument')
      }

      return applyTransform(left, m)
    }
  }

  if(isSameType(First, first)) {
    return applyTransform(left, first)
  }

  throw new TypeError('firstToResult: First or First returing function required for second argument')
}

module.exports = curry(firstToResult)


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Result = __webpack_require__(24)
var Last = __webpack_require__(3).proxy('Last')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

var applyTransform = function (left, last) { return last.valueOf().either(
    constant(Result.Err(left)),
    Result.Ok
  ); }

// lastToResult : c -> Last a -> Result c a
// lastToResult : c -> (a -> Last b) -> a -> Result c b
function lastToResult(left, last) {
  if(isFunction(last)) {
    return function(x) {
      var m = last(x)

      if(!isSameType(Last, m)) {
        throw new TypeError('lastToResult: Last returing function required for second argument')
      }

      return applyTransform(left, m)
    }
  }

  if(isSameType(Last, last)) {
    return applyTransform(left, last)
  }

  throw new TypeError('lastToResult: Last or Last returing function required for second argument')
}

module.exports = curry(lastToResult)


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Result = __webpack_require__(24)
var Maybe = __webpack_require__(3).proxy('Maybe')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

var applyTransform = function (left, maybe) { return maybe.either(
    constant(Result.Err(left)),
    Result.Ok
  ); }

// maybeToResult : c -> Maybe a -> Result c a
// maybeToResult : c -> (a -> Maybe b) -> a -> Result c b
function maybeToResult(left, maybe) {
  if(isFunction(maybe)) {
    return function(x) {
      var m = maybe(x)

      if(!isSameType(Maybe, m)) {
        throw new TypeError('maybeToResult: Maybe returing function required for second argument')
      }

      return applyTransform(left, m)
    }
  }

  if(isSameType(Maybe, maybe)) {
    return applyTransform(left, maybe)
  }

  throw new TypeError('maybeToResult: Maybe or Maybe returing function required for second argument')
}

module.exports = curry(maybeToResult)


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var ref = __webpack_require__(24);
var Err = ref.Err;
var Ok = ref.Ok;
var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function tryCatch(fn) {
  if(!isFunction(fn)) {
    throw new TypeError('tryCatch: Function required for first argument')
  }

  return function(x) {
    try { return Ok(fn(x)) }
    catch(e) { return Err(e) }
  }
}

module.exports = curry(tryCatch)


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var _type = __webpack_require__(3).type('Star')

var array = __webpack_require__(15)
var isFunction = __webpack_require__(0)
var isMonad = __webpack_require__(49)
var isSameType = __webpack_require__(2)

var Pair = __webpack_require__(19)

var merge =
  function (fn, m) { return m.merge(fn); }

var sequence =
  function (af, m) { return array.sequence(af, m); }

function _Star(Monad) {
  if(!isMonad(Monad)) {
    throw new TypeError('Star: Monad required for construction')
  }

  var _id =
    function () { return Star(Monad.of); }

  var innerType =
    Monad.type()

  var outerType =
    (_type()) + "( " + innerType + " )"

  var type =
    function () { return outerType; }

  function Star(runWith) {
    if(!isFunction(runWith)) {
      throw new TypeError((outerType + ": Function in the form (a -> m b) required"))
    }

    var inspect =
      function () { return ("" + outerType + (_inspect(runWith))); }

    var id =
      _id

    function compose(s) {
      if(!isSameType(Star, s)) {
        throw new TypeError((outerType + ".compose: " + outerType + " required"))
      }

      return Star(function(x) {
        var m = runWith(x)

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".compose: Computations must return a type of " + innerType))
        }

        return m.chain(function(val) {
          var inner = s.runWith(val)

          if(!isSameType(m, inner)) {
            throw new TypeError((outerType + ".compose: Both computations must return a type of " + innerType))
          }

          return inner
        })
      })
    }

    function map(fn) {
      if(!isFunction(fn)) {
        throw new TypeError((outerType + ".map: Function required"))
      }

      return Star(function(x) {
        var m = runWith(x)

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".map: Computations must return a type of " + innerType))
        }

        return m.map(fn)
      })
    }

    function contramap(fn) {
      if(!isFunction(fn)) {
        throw new TypeError((outerType + ".contramap: Function required"))
      }

      return Star(function (x) { return runWith(fn(x)); })
    }

    function promap(l, r) {
      if(!isFunction(l) || !isFunction(r)) {
        throw new TypeError((outerType + ".promap: Functions required for both arguments"))
      }

      return Star(function(x) {
        var m = runWith(l(x))

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".promap: Computation must return a type of " + innerType))
        }

        return m.map(r)
      })
    }

    function first() {
      return Star(function(x) {
        if(!isSameType(Pair, x)) {
          throw TypeError((outerType + ".first: Pair required for computation input"))
        }

        var m = runWith(x.fst())

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".first: Computation must return a type of " + innerType))
        }

        return m.map(function (l) { return Pair(l, x.snd()); })
      })
    }

    function second() {
      return Star(function(x) {
        if(!isSameType(Pair, x)) {
          throw TypeError((outerType + ".second: Pair required for computation input"))
        }

        var m = runWith(x.snd())

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".second: Computation must return a type of " + innerType))
        }

        return m.map(function (r) { return Pair(x.fst(), r); })
      })
    }

    function both() {
      return Star(function(x) {
        if(!isSameType(Pair, x)) {
          throw TypeError((outerType + ".both: Pair required for computation input"))
        }

        var p = x.bimap(runWith, runWith)
        var m = p.fst()

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".both: Computation must return a type of " + innerType))
        }

        return sequence(m.of, merge(function (x, y) { return [ x, y ]; }, p)).map(function (x) { return Pair(x[0], x[1]); })
      })
    }

    return {
      inspect: inspect, type: type, runWith: runWith,
      id: id, compose: compose, map: map, contramap: contramap,
      promap: promap, first: first, second: second, both: both
    }
  }

  Star.id = _id
  Star.type = type

  Star['@@implements'] = _implements(
    [ 'compose', 'contramap', 'id', 'map', 'promap' ]
  )

  return Star
}

module.exports = _Star


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function evalWith(x, m) {
  if(!(m && isFunction(m.evalWith))) {
    throw new TypeError('evalWith: State required for second argument')
  }

  return m.evalWith(x)
}

module.exports = curry(evalWith)


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function execWith(x, m) {
  if(!(m && isFunction(m.execWith))) {
    throw new TypeError('execWith: State required for second argument')
  }

  return m.execWith(x)
}

module.exports = curry(execWith)


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('State')

var Pair = __webpack_require__(19)
var Unit = __webpack_require__(45)

var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var _of =
  function (x) { return State(function (s) { return Pair(x, s); }); }

function get(fn) {
  if(!arguments.length) {
    return State(function (s) { return Pair(s, s); })
  }

  if(isFunction(fn)) {
    return State(function (s) { return Pair(fn(s), s); })
  }

  throw new TypeError('State.get: No arguments or function required')
}

function modify(fn) {
  if(!isFunction(fn)) {
    throw new TypeError('State.modify: Function Required')
  }

  return State(function (s) { return Pair(Unit(), fn(s)); })
}

function State(fn) {
  if(!isFunction(fn)) {
    throw new TypeError('State: Must wrap a function in the form (s -> Pair a s)')
  }

  var of =
    _of

  var inspect =
    function () { return ("State" + (_inspect(fn))); }

  function runWith(state) {
    var params = [], len = arguments.length - 1;
    while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];

    var func = params[0]; if ( func === void 0 ) func = 'runWith';
    var m = fn(state)

    if(!isSameType(Pair, m)) {
      throw new TypeError(("State." + func + ": Must wrap a function in the form (s -> Pair a s)"))
    }

    return m
  }

  function execWith(s) {
    var pair = runWith(s, 'execWith')
    return pair.snd()
  }

  function evalWith(s) {
    var pair = runWith(s, 'evalWith')
    return pair.fst()
  }

  function map(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('State.map: Function required')
    }

    return State(function (s) {
      var m = runWith(s, 'map')
      return Pair(fn(m.fst()), m.snd())
    })
  }

  function ap(m) {
    if(!isSameType(State, m)) {
      throw new TypeError('State.ap: State required')
    }

    return State(function (s) {
      var pair = runWith(s, 'ap')
      var fn = pair.fst()

      if(!isFunction(fn)) {
        throw new TypeError('State.ap: Source value must be a function')
      }

      return m.map(fn).runWith(pair.snd())
    })
  }

  function chain(fn) {
    if(!isFunction(fn)) {
      throw new TypeError('State.chain: State returning function required')
    }

    return State(function (s) {
      var pair = runWith(s, 'chain')
      var m = fn(pair.fst())

      if(!isSameType(State, m)) {
        throw new TypeError('State.chain: Function must return another State')
      }

      return m.runWith(pair.snd())
    })
  }

  return {
    runWith: runWith, execWith: execWith, evalWith: evalWith,
    inspect: inspect, type: type, map: map, ap: ap, chain: chain,
    of: of
  }
}

State.of = _of
State.type = type
State.get = get

State.modify = modify

State.put =
  function (x) { return modify(function () { return (x); }); }

State['@@implements'] = _implements(
  [ 'ap', 'chain', 'map', 'of' ]
)

module.exports = State


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var type = __webpack_require__(3).type('Sum')

var isNil = __webpack_require__(11)
var isNumber = __webpack_require__(21)
var isSameType = __webpack_require__(2)

var _empty =
  function () { return Sum(0); }

function Sum(n) {
  var x = isNil(n) ? _empty().valueOf() : n

  if(!arguments.length || !isNumber(x)) {
    throw new TypeError('Sum: Numeric value required')
  }

  var valueOf =
    function () { return x; }

  var empty=
    _empty

  var inspect =
    function () { return ("Sum" + (_inspect(valueOf()))); }

  function concat(m) {
    if(!isSameType(Sum, m)) {
      throw new TypeError('Sum.concat: Sum required')
    }

    return Sum(x + m.valueOf())
  }

  return { inspect: inspect, valueOf: valueOf, type: type, concat: concat, empty: empty }
}

Sum['@@implements'] = _implements(
  [ 'concat', 'empty' ]
)

Sum.empty = _empty
Sum.type = type

module.exports = Sum


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(45)


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _equals = __webpack_require__(16)
var _implements = __webpack_require__(4)
var _inspect = __webpack_require__(5)
var __type = __webpack_require__(3).type('Writer')
var Pair = __webpack_require__(19)

var isFunction = __webpack_require__(0)
var isMonoid = __webpack_require__(25)
var isSameType = __webpack_require__(2)

var constant = function (x) { return function () { return x; }; }

function _Writer(Monoid) {
  if(!isMonoid(Monoid)) {
    throw new TypeError('Writer: Monoid required for construction')
  }

  var _of =
    function (x) { return Writer(Monoid.empty().valueOf(), x); }

  var _type =
    function () { return ((__type()) + "( " + (Monoid.type()) + " )"); }

  function Writer(entry, val) {
    if(arguments.length !== 2) {
      throw new TypeError('Writer: Log entry and a value required')
    }

    var type =
      _type

    var of =
      _of

    var equals =
      function (m) { return isSameType(Writer, m)
        && _equals(m.valueOf(), val); }

    var valueOf =
      constant(val)

    var log =
      constant(Monoid(entry))

    var inspect =
      constant(("Writer(" + (_inspect(log())) + (_inspect(valueOf())) + " )"))

    var read = function () { return Pair(log(), val); }

    function map(fn) {
      if(!isFunction(fn)) {
        throw new TypeError('Writer.map: Function required')
      }

      return Writer(log().valueOf(), fn(valueOf()))
    }

    function ap(m) {
      if(!isFunction(valueOf())) {
        throw new TypeError('Writer.ap: Wrapped value must be a function')
      }
      else if(!isSameType(Writer, m)) {
        throw new TypeError('Writer.ap: Writer required')
      }

      return chain(function (fn) { return m.map(fn); })
    }

    function chain(fn) {
      if(!isFunction(fn)) {
        throw new TypeError('Writer.chain: Function required')
      }

      var w = fn(valueOf())

      if(!isSameType(Writer, w)) {
        throw new TypeError('Writer.chain: Function must return a Writer')
      }

      return Writer(log().concat(w.log()).valueOf(), w.valueOf())
    }

    return {
      inspect: inspect, read: read, valueOf: valueOf,
      log: log, type: type, equals: equals, map: map,
      ap: ap, of: of, chain: chain
    }
  }

  Writer.of =
    _of

  Writer.type =
    _type

  Writer['@@implements'] = _implements(
    [ 'ap', 'chain', 'equals', 'map', 'of' ]
  )

  return Writer
}


module.exports = _Writer


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

function log(m) {
  if(!(m && isFunction(m.log))) {
    throw new TypeError('log: Writer required')
  }

  return m.log()
}

module.exports = log


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

function read(m) {
  if(!(m && isFunction(m.read))) {
    throw new TypeError('read: Writer required')
  }

  return m.read()
}

module.exports = read



/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

// Applicator
// applyTo :: (a -> b) -> a -> b
function applyTo(fn, x) {
  if(!isFunction(fn)) {
    throw new TypeError('applyTo: Function required for first argument')
  }

  return fn(x)
}

module.exports = curry(applyTo)


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var compose = __webpack_require__(9)
var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

// Composition (Bluebird)
// composeB :: (b -> c) -> (a -> b) -> a -> c
function composeB(f, g) {
  if(!isFunction(f) || !isFunction(g)) {
    throw new TypeError('composeB: Functions required for first two arguments')
  }

  return compose(f, g)
}

module.exports = curry(composeB)


/***/ }),
/* 116 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// Constant (Kestrel)
// constant : a -> b -> a
var constant =
  function (x) { return function () { return x; }; }

module.exports = constant


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

// Flip (Cardinal)
//  flip :: (a -> b -> c) -> b -> a -> c
function flip(f, x, y) {
  if(!isFunction(f)) {
    throw new TypeError('flip: Function required for first argument')
  }

  return curry(f)(y, x)
}

module.exports = curry(flip)


/***/ }),
/* 118 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// Identity (Idiot)
// identity :: a -> a
var identity =
  function (x) { return x; }

module.exports = identity


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

// Reverse Application (Thrush)
// reverseApply :: a -> (a -> b) -> b
function reverseApply(x, f) {
  if(!isFunction(f)) {
    throw new TypeError('reverseApply: Function required for second argument')
  }

  return f(x)
}

module.exports = curry(reverseApply)


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

// Substitution (Starling)
// substitution : (a -> b -> c) -> (a -> b) -> a -> c
function substitution(f, g, x) {
  if(!isFunction(f) || !isFunction(g)) {
    throw new TypeError('substitution: Functions required for first two arguments')
  }

  return curry(f)(x, g(x))
}

module.exports = curry(substitution)


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isObject = __webpack_require__(8)
var object = __webpack_require__(22)

// assign : Object -> Object -> Object
function assign(x, m) {
  if(!(isObject(x) && isObject(m))) {
    throw new TypeError('assign: Objects required for both arguments')
  }

  return object.assign(x, m)
}

module.exports = curry(assign)


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isObject = __webpack_require__(8)
var isString = __webpack_require__(10)
var object = __webpack_require__(22)

// assoc : String -> a -> Object -> Object
function assoc(key, val, obj) {
  if(!isString(key)) {
    throw new TypeError('assoc: String required for first argument')
  }

  if(!isObject(obj)) {
    throw new TypeError('assoc: Object required for third argument')
  }
  return object.assign(( obj$1 = {}, obj$1[key] = val, obj$1 ), obj)
  var obj$1;
}

module.exports = curry(assoc)


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curryN = __webpack_require__(47)
var isFunction = __webpack_require__(0)

// binary : (* -> c) -> a -> b -> c
function binary(fn) {
  if(!isFunction(fn)) {
    throw new TypeError('binary: Function required')
  }

  return curryN(2, fn)
}

module.exports = binary


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

var err = 'compose: Functions required'

function applyPipe(f, g) {
  if(!isFunction(g)) {
    throw new TypeError(err)
  }

  return function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return g.call(null, f.apply(null, args));
  }
}

// compose : ((y -> z), (x -> y), ..., (a -> b)) -> a -> z
function compose() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  if(!arguments.length) {
    throw new TypeError(err)
  }

  var fns =
    args.slice().reverse()

  var head =
    fns[0]

  if(!isFunction(head)) {
    throw new TypeError(err)
  }

  var tail =
    fns.slice(1).concat(function (x) { return x; })

  return tail.reduce(applyPipe, head)
}

module.exports = compose


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isChain = __webpack_require__(32)
var isFunction = __webpack_require__(0)

var err = 'composeK: Chain returning functions of the same type required'

// composeK : Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> a -> m z
function composeK() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  if(!(arguments.length)) {
    throw new TypeError(err)
  }

  var fns =
    args.slice().reverse()

  var head =
    fns[0]

  if(!isFunction(head)) {
    throw new TypeError(err)
  }

  if(fns.length === 1) {
    return head
  }

  var tail = fns.slice(1).reduce(function (comp, fn) {
    if(!isFunction(fn)) {
      throw new TypeError(err)
    }

    return function(m) {
      if(!isChain(m)) {
        throw new TypeError(err)
      }
      return comp(m).chain(fn)
    }
  }, function (x) { return x; })

  return function() {
    return tail(head.apply(null, arguments))
  }
}

module.exports = composeK


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)
var isPromise = __webpack_require__(35)

var err = 'composeP: Promise returning functions required'

function applyPipe(f, g) {
  if(!isFunction(g)) {
    throw new TypeError(err)
  }

  return function() {
    var p = f.apply(null, arguments)

    if(!isPromise(p)) {
      throw new TypeError(err)
    }

    return p.then(g)
  }
}

function composeP() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  if(!arguments.length) {
    throw new TypeError(err)
  }

  var fns =
    args.reverse()

  var head =
    fns[0]

  if(!isFunction(head)) {
    throw new TypeError(err)
  }

  var tail =
    fns.slice(1).concat(function (x) { return x; })

  return tail.reduce(applyPipe, head)
}

module.exports = composeP


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isSameType = __webpack_require__(2)
var isSemigroupoid = __webpack_require__(30)

var err = 'composeS: Semigroupoids of the same type required'

// composeS : Semigroupoid s => (s y z, s x y, ..., s a b) -> s a z
function composeS() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  if(!(arguments.length)) {
    throw new TypeError(err)
  }

  var ms =
    args.slice().reverse()

  var head =
    ms[0]

  if(!isSemigroupoid(head)) {
    throw new TypeError(err)
  }

  if(ms.length === 1) {
    return head
  }

  return ms.slice().reduce(function (comp, m) {
    if(!isSameType(comp, m)) {
      throw new TypeError(err)
    }

    return comp.compose(m)
  })
}

module.exports = composeS


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

// curry : ((a, b, c) -> d) -> a -> b -> c -> d
function curry(fn) {
  if(!isFunction(fn)) {
    throw new TypeError('curry: Function required')
  }

  return _curry(fn)
}

module.exports = curry


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isObject = __webpack_require__(8)
var object = __webpack_require__(22)

// defaultProps : Object -> Object -> Object
function defaultProps(x, m) {
  if(!isObject(x) || !isObject(m)) {
    throw new TypeError('defaultProps: Objects required for both arguments')
  }

  return object.assign(m, x)
}

module.exports = curry(defaultProps)


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isNil = __webpack_require__(11)

// defaultTo : a -> b -> (a | b)
function defaultTo(def, val) {
  return isNil(val) ? def : val
}

module.exports = curry(defaultTo)


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isString = __webpack_require__(10)
var isObject  = __webpack_require__(8)

function applyDissoc(key, obj) {
  return function(acc, k) {
    if(obj[k] !== undefined && k !== key) {
      acc[k] = obj[k]
    }
    return acc
  }
}

// dissoc : String -> Object -> Object
function dissoc(key, obj) {
  if(!isString(key)) {
    throw new TypeError('dissoc: String required for first argument')
  }

  if(!isObject(obj)) {
    throw new TypeError('dissoc: Object required for second argument')
  }

  return Object.keys(obj).reduce(applyDissoc(key, obj), {})
}

module.exports = curry(dissoc)


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pair = __webpack_require__(19)

var curry = __webpack_require__(1)
var isContravariant = __webpack_require__(41)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)
var isSemigroupoid = __webpack_require__(30)

var valid = function (x, y) { return isSameType(x, y)
    && isSemigroupoid(x)
    && isContravariant(x)
    && isFunction(x.first)
    && isFunction(x.second); }

// fanout : m a b -> m a c -> m a (b, c)
function fanout(fst, snd) {
  if(isFunction(fst) && isFunction(snd)) {
    return function (x) { return Pair(fst(x), snd(x)); }
  }

  if(valid(fst, snd)) {
    return fst.first()
      .compose(snd.second())
      .contramap(function (x) { return Pair(x, x); })
  }

  throw new TypeError('fanout: Arrows, Functions or Stars of the same type required for both arguments')
}

module.exports = curry(fanout)


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pair = __webpack_require__(3).proxy('Pair')

var isFoldable = __webpack_require__(12)
var isSameType = __webpack_require__(2)
var isString = __webpack_require__(10)

function foldPairs(acc, pair) {
  if(!isSameType(Pair, pair)) {
    throw new TypeError('fromPairs: Foldable of Pairs required for argument')
  }

  var key = pair.fst()
  var value = pair.snd()

  if(!isString(key)) {
    throw new TypeError('fromPairs: String required for fst of every Pair')
  }

  return value !== undefined
    ? Object.assign(acc, ( obj = {}, obj[key] = value, obj ))
    : acc
  var obj;
}

// fromPairs : Foldable f => f (Pair String a) -> Object
function fromPairs(xs) {
  if(!isFoldable(xs)) {
    throw new TypeError('fromPairs: Foldable of Pairs required for argument')
  }

  return xs.reduce(foldPairs, {})
}

module.exports = fromPairs


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var array = __webpack_require__(15)
var curry = __webpack_require__(1)
var isApply = __webpack_require__(29)
var isArray = __webpack_require__(7)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var map = array.map
var ap = array.ap

// liftA2 :: Applicative m => (a -> b -> c) -> m a -> m b -> m c
function liftA2(fn, x, y) {
  if(!isFunction(fn)) {
    throw new TypeError('liftA2: Function required for first argument')
  }
  else if(!((isApply(x) || isArray(x)) && isSameType(x, y))) {
    throw new TypeError('liftA2: Applys of same type required for last two arguments')
  }

  if(isArray(x)) {
    return ap(y, map(fn, x))
  }

  return x.map(fn).ap(y)
}

module.exports = curry(liftA2)


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var array = __webpack_require__(15)
var curry = __webpack_require__(1)
var isApply = __webpack_require__(29)
var isArray = __webpack_require__(7)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var map = array.map
var ap = array.ap

// liftA3 :: Applicative m => (a -> b -> c -> d) -> m a -> m b -> m c -> m d
function liftA3(fn, x, y, z) {
  if(!isFunction(fn)) {
    throw new TypeError('liftA3: Function required for first argument')
  }
  else if(!((isApply(x) || isArray(x)) && isSameType(x, y) && isSameType(x, z))) {
    throw new TypeError('liftA3: Applys of same type required for last three arguments')
  }

  if(isArray(x)) {
    return ap(z, ap(y, map(fn, x)))
  }

  return x.map(fn).ap(y).ap(z)
}

module.exports = curry(liftA3)


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isObject = __webpack_require__(8)
var isFunction = __webpack_require__(0)
var isNil = __webpack_require__(11)

// applyMap :: ({ (* -> *) }, Object) -> (Object , String) -> Object
var applyMap = function (fns, obj) { return function(acc, key) {
    if(isNil(fns[key])) {
      return Object.assign({}, acc, ( obj$1 = {}, obj$1[key] = obj[key], obj$1 ))
      var obj$1;
    }

    if(isObject(fns[key])) {
      return Object.assign({}, acc, ( obj$2 = {}, obj$2[key] = isObject(obj[key]) ? mapProps(fns[key], obj[key]) : obj[key], obj$2 ))
      var obj$2;
    }

    if(!isFunction(fns[key])) {
      throw new TypeError('mapProps: Object of functions required for first argument')
    }

    return Object.assign({}, acc, ( obj$3 = {}, obj$3[key] = fns[key](obj[key]), obj$3 ))
    var obj$3;
  }; }

// mapProps :: { (* -> *) } -> Object -> Object
function mapProps(fns, obj) {
  if(!(isObject(fns) && isObject(obj))) {
    throw new TypeError('mapProps: Objects required for both arguments')
  }

  return Object.keys(obj)
    .reduce(applyMap(fns, obj), {})
}

module.exports = curry(mapProps)


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFoldable = __webpack_require__(12)
var isFunction = __webpack_require__(0)

function mapReduce(mapFn, reduceFn, empty, xs) {
  if(!isFunction(mapFn)) {
    throw new TypeError('mapReduce: Unary mapping function required for first argument')
  }

  if(!isFunction(reduceFn)) {
    throw new TypeError('mapReduce: Binary reduction function required for second argument')
  }

  if(!isFoldable(xs)) {
    throw new TypeError('mapReduce: Foldable required for fourth argument')
  }

  return xs.reduce(
    function (acc, x) { return reduceFn(acc, mapFn(x)); },
    empty
  )
}

module.exports = curry(mapReduce)


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFoldable = __webpack_require__(12)
var isMonoid = __webpack_require__(25)
var mconcatMap = __webpack_require__(36)

var identity = function (x) { return x; }

// mconcat : Monoid m => m -> ([ a ] | List a) -> m a
function mconcat(M, xs) {
  if(!(M && isMonoid(M))) {
    throw new TypeError('mconcat: Monoid required for first argument')
  }

  if(!(isFoldable(xs))) {
    throw new TypeError('mconcat: Foldable required for second argument')
  }

  return mconcatMap(M, identity, xs)
}

module.exports = curry(mconcat)


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _mconcatMap = __webpack_require__(36)
var curry = __webpack_require__(1)
var isFoldable = __webpack_require__(12)
var isFunction = __webpack_require__(0)
var isMonoid = __webpack_require__(25)

// mconcatMap : Monoid M => M -> (b -> a) -> ([ b ] | List b) -> M a
function mconcatMap(M, f, xs) {
  if(!(M && isMonoid(M))) {
    throw new TypeError('mconcatMap: Monoid required for first argument')
  }

  if(!isFunction(f)) {
    throw new TypeError('mconcatMap: Function required for second argument')
  }

  if(!(isFoldable(xs))) {
    throw new TypeError('mconcatMap: Foldable required for third argument')
  }

  return _mconcatMap(M, f, xs)
}

module.exports = curry(mconcatMap)


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFoldable = __webpack_require__(12)
var isMonoid = __webpack_require__(25)
var mconcatMap = __webpack_require__(36)

var identity = function (x) { return x; }

// mreduce : Monoid M => M -> ([ a ] | List a) -> a
function mreduce(M, xs) {
  if(!(M && isMonoid(M))) {
    throw new TypeError('mreduce: Monoid required for first argument')
  }
  else if(!(isFoldable(xs))) {
    throw new TypeError('mreduce: Foldable required for second argument')
  }

  return mconcatMap(M, identity, xs).valueOf()
}

module.exports = curry(mreduce)


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFoldable = __webpack_require__(12)
var isFunction = __webpack_require__(0)
var isMonoid = __webpack_require__(25)
var mconcatMap = __webpack_require__(36)

// mreduceMap :: Monoid M => M -> (b -> a) -> ( [ b ] | List b ) -> a
function mreduceMap(M, f, xs) {
  if(!(M && isMonoid(M))) {
    throw new TypeError('mreduceMap: Monoid required for first argument')
  }
  else if(!isFunction(f)) {
    throw new TypeError('mreduceMap: Function required for second argument')
  }
  else if(!(isFoldable(xs))) {
    throw new TypeError('mreduceMap: Foldable required for third argument')
  }

  return mconcatMap(M, f, xs).valueOf()
}

module.exports = curry(mreduceMap)


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var curryN = __webpack_require__(47)
var isFunction = __webpack_require__(0)
var isNumber = __webpack_require__(21)

// nAry : Number -> (* -> a) -> * -> * -> a
function nAry(num, fn) {
  if(!isNumber(num)) {
    throw new TypeError('nAry: Number required for first argument')
  }

  if(!isFunction(fn)) {
    throw new TypeError('nAry: Function required for second argument')
  }

  return curryN(num, fn)
}

module.exports = curry(nAry)


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isString = __webpack_require__(10)

// objOf : String -> a -> Object
function objOf(key, value) {
  if(!(key && isString(key))) {
    throw new TypeError('objOf: Non-empty String required for first argument')
  }

  return (( obj = {}, obj[key] = value, obj ))
  var obj;
}

module.exports = curry(objOf)


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFoldable = __webpack_require__(12)
var isObject  = __webpack_require__(8)

function omitKeys(keys, obj) {
  return function(acc, key) {
    return keys.indexOf(key) === -1 && obj[key] !== undefined
      ? Object.assign(acc, ( obj$1 = {}, obj$1[key] = obj[key], obj$1 ))
      : acc
    var obj$1;
  }
}

// omit : ([ String ] | List String) -> Object -> Object
function omit(keys, obj) {
  if(!isFoldable(keys)) {
    throw new TypeError('omit: Foldable required for first argument')
  }
  else if(!isObject(obj)) {
    throw new TypeError('omit: Object required for second argument')
  }

  return Object.keys(obj).reduce(omitKeys(keys, obj), {})
}

module.exports = curry(omit)


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)
var _once = __webpack_require__(52)

// once : ((*) -> b) -> ((*) -> b)
function once(fn) {
  if(!isFunction(fn)) {
    throw new TypeError('once: Function required')
  }

  return _once(fn)
}

module.exports = once


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

// partial : ((* -> c), *) -> * -> c
function partial() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  var fn = args[0]
  var xs = args.slice(1)

  if(!isFunction(fn)) {
    throw new TypeError('partial: Function required for first argument')
  }

  return curry(
    Function.bind.apply(fn, [ null ].concat(xs))
  )
}

module.exports = partial


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFoldable = __webpack_require__(12)
var isObject  = __webpack_require__(8)
var isString = __webpack_require__(10)

function pickKeys(obj) {
  return function(acc, key) {
    if(!isString(key)) {
      throw new TypeError('pick: Foldable of Strings is required for first argument')
    }
    return key && obj[key] !== undefined
      ? Object.assign(acc, ( obj$1 = {}, obj$1[key] = obj[key], obj$1 ))
      : acc
    var obj$1;
  }
}

// pick : ([ String ] | List String) -> Object -> Object
function pick(keys, obj) {
  if(!isFoldable(keys)) {
    throw new TypeError('pick: Foldable required for first argument')
  }
  else if(!isObject(obj)) {
    throw new TypeError('pick: Object required for second argument')
  }

  return keys.reduce(pickKeys(obj), {})
}

module.exports = curry(pick)


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

var err = 'pipe: Functions required'

function applyPipe(f, g) {
  if(!isFunction(g)) {
    throw new TypeError(err)
  }

  return function() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return g.call(null, f.apply(null, args))
  }
}

// pipe : ((a -> b), (b -> c), ..., (y -> z)) -> a -> z
function pipe() {
  var fns = [], len = arguments.length;
  while ( len-- ) fns[ len ] = arguments[ len ];

  if(!arguments.length) {
    throw new TypeError(err)
  }

  var head =
    fns[0]

  if(!isFunction(head)) {
    throw new TypeError(err)
  }

  var tail =
    fns.slice(1).concat(function (x) { return x; })

  return tail.reduce(applyPipe, head)
}

module.exports = pipe


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isChain = __webpack_require__(32)
var isFunction = __webpack_require__(0)

var err = 'pipeK: Chain returning functions of the same type required'

function pipeK(head) {
  var fns = [], len = arguments.length - 1;
  while ( len-- > 0 ) fns[ len ] = arguments[ len + 1 ];

  if(!(arguments.length && isFunction(head))) {
    throw new TypeError(err)
  }

  if(arguments.length === 1) {
    return head
  }

  var tail = fns.reduce(function (comp, fn) {
    if(!isFunction(fn)) {
      throw new TypeError(err)
    }

    return function(m) {
      if(!isChain(m)) {
        throw new TypeError(err)
      }
      return comp(m).chain(fn)
    }
  }, function (x) { return x; })

  return function() {
    return tail(head.apply(null, arguments))
  }
}

module.exports = pipeK


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)
var isPromise = __webpack_require__(35)

var err = 'pipeP: Promise returning functions required'

function applyPipe(f, g) {
  if(!isFunction(g)) {
    throw new TypeError(err)
  }

  return function() {
    var p = f.apply(null, arguments)

    if(!isPromise(p)) {
      throw new TypeError(err)
    }

    return p.then(g)
  }
}

// pipeP : Promise p => ((a -> p b), (b -> p c), ..., (y -> p z)) -> a -> p z
function pipeP() {
  var fns = [], len = arguments.length;
  while ( len-- ) fns[ len ] = arguments[ len ];

  if(!arguments.length) {
    throw new TypeError(err)
  }

  var head =
    fns[0]

  if(!isFunction(head)) {
    throw new TypeError(err)
  }

  var tail =
    fns.slice(1).concat(function (x) { return x; })

  return tail.reduce(applyPipe, head)
}

module.exports = pipeP


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isSameType = __webpack_require__(2)
var isSemigroupoid = __webpack_require__(30)

var err = 'pipeS: Semigroupoids of the same type required'

// pipeS : Semigroupoid s => (s a b, s b c, ..., s y z) -> s a z
function pipeS() {
  var ms = [], len = arguments.length;
  while ( len-- ) ms[ len ] = arguments[ len ];

  if(!(arguments.length)) {
    throw new TypeError(err)
  }

  var head =
    ms[0]

  if(!isSemigroupoid(head)) {
    throw new TypeError(err)
  }

  if(ms.length === 1) {
    return head
  }

  return ms.slice().reduce(function (comp, m) {
    if(!isSameType(comp, m)) {
      throw new TypeError(err)
    }

    return comp.compose(m)
  })
}

module.exports = pipeS


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var compose = __webpack_require__(9)
var isFunction = __webpack_require__(0)

var constant = function (x) { return function () { return x; }; }

// tap : (a -> b) -> a -> a
function tap(fn, x) {
  if(!isFunction(fn)) {
    throw new TypeError('tap: Function required for first argument')
  }

  return compose(constant(x), fn)(x)
}

module.exports = curry(tap)


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

// unary : (* -> b) -> a -> b
function unary(fn) {
  if(!isFunction(fn)) {
    throw new TypeError('unary: Function required')
  }

  return function(x) {
    return fn(x)
  }
}

module.exports = unary


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(46)


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pred = __webpack_require__(3).proxy('Pred')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)
var predOrFunc = __webpack_require__(17)

// and : (a -> Boolean) | Pred -> (a -> Boolean) | Pred -> a -> Boolean
function and(f, g) {
  if(!((isFunction(f) || isSameType(Pred, f)) && (isFunction(g) || isSameType(Pred, g)))) {
    throw new TypeError('and: Preds or predicate functions required for first two arguments')
  }

  return function (x) { return !!(predOrFunc(f, x) && predOrFunc(g, x)); }
}

module.exports = curry(and)


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pred = __webpack_require__(3).proxy('Pred')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

// ifElse : (a -> Boolean) | Pred -> (a -> b) -> (a -> c) -> a -> (a | c)
function ifElse(pred, f, g) {
  if(!(isFunction(pred) || isSameType(Pred, pred))) {
    throw new TypeError('ifElse: Pred or predicate function required for first argument')
  }

  if(!isFunction(f) || !isFunction(g)) {
    throw new TypeError('ifElse: Functions required for second and third arguments')
  }

  var func =
    isFunction(pred) ? pred : pred.runWith

  return function (x) { return func(x) ? f(x) : g(x); }
}

module.exports = curry(ifElse)


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pred = __webpack_require__(3).proxy('Pred')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)
var predOrFunc = __webpack_require__(17)

// not : (a -> Boolean) | Pred -> a -> Boolean
function not(pred, x) {
  if(!(isFunction(pred) || isSameType(Pred, pred))) {
    throw new TypeError('not: Pred or predicate function required for first argument')
  }

  return !predOrFunc(pred, x)
}

module.exports = curry(not)


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pred = __webpack_require__(3).proxy('Pred')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)
var predOrFunc = __webpack_require__(17)

// or : (a -> Boolean) | Pred -> (a -> Boolean) | Pred -> a -> Boolean
function or(f, g) {
  if(!((isFunction(f) || isSameType(Pred, f)) && (isFunction(g) || isSameType(Pred, g)))) {
    throw new TypeError('or: Preds or predicate functions required for first two arguments')
  }

  return function (x) { return !!(predOrFunc(f, x) || predOrFunc(g, x)); }
}

module.exports = curry(or)


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pred = __webpack_require__(3).proxy('Pred')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)
var predOrFunc = __webpack_require__(17)

// unless : (a -> Boolean) | Pred -> (a -> b) -> a | b
function unless(pred, f) {
  if(!(isFunction(pred) || isSameType(Pred, pred))) {
    throw new TypeError('unless: Pred or predicate function required for first argument')
  }

  if(!isFunction(f)) {
    throw new TypeError('unless: Function required for second argument')
  }

  return function(x) {
    if(!predOrFunc(pred, x)) {
      return f(x)
    }
    return x
  }
}

module.exports = curry(unless)


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pred = __webpack_require__(3).proxy('Pred')

var curry = __webpack_require__(1)
var predOrFunc = __webpack_require__(17)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

// when : (a -> Boolean) | Pred -> (a -> b) -> a -> b | a
function when(pred, f) {
  if(!(isFunction(pred) || isSameType(Pred, pred))) {
    throw new TypeError('when: Pred or predicate function required for first argument')
  }

  if(!isFunction(f)) {
    throw new TypeError('when: Function required for second argument')
  }

  return function(x) {
    if(predOrFunc(pred, x)) {
      return f(x)
    }
    return x
  }
}

module.exports = curry(when)


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isAlt = __webpack_require__(40)
var isSameType = __webpack_require__(2)

// alt : Alt m => m a -> m a -> m a
function alt(m, x) {
  if(!(isAlt(m) && isSameType(m, x))) {
    throw new TypeError('alt: Both arguments must be Alts of the same type')
  }

  return x.alt(m)
}

module.exports = curry(alt)


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var array = __webpack_require__(15)
var curry = __webpack_require__(1)
var isApplicative = __webpack_require__(13)
var isArray = __webpack_require__(7)
var isSameType = __webpack_require__(2)

// ap :: Applicative m => m a -> m (a -> b) ->  m b
function ap(m, x) {
  if(!((isApplicative(m) || isArray(m)) && isSameType(m, x))) {
    throw new TypeError('ap: Both arguments must be Applys of the same type')
  }

  if(isArray(x)) {
    return array.ap(m, x)
  }

  return x.ap(m)
}

module.exports = curry(ap)


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function bimap(f, g, m) {
  if(!isFunction(f) || !isFunction(g)) {
    throw new TypeError('bimap: Function required for first two arguments')
  }
  else if(!isFunction(m.bimap)) {
    throw new TypeError('bimap: Bifunctor required for third argument')
  }

  return m.bimap(f, g)
}

module.exports = curry(bimap)


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pair = __webpack_require__(3).proxy('Pair')

var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

function both(m) {
  if(isFunction(m)) {
    return function(x) {
      if(!isSameType(Pair, x)) {
        throw new TypeError('both: Pair required as input')
      }

      return x.bimap(m, m)
    }
  }

  if(m && isFunction(m.both)) {
    return m.both()
  }

  throw new TypeError('both: Arrow, Function or Star required')
}

module.exports = both


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _chain = __webpack_require__(15).chain
var curry = __webpack_require__(1)
var isArray = __webpack_require__(7)
var isChain = __webpack_require__(32)
var isFunction = __webpack_require__(0)

// chain : Chain m => (a -> m b) -> m a -> m b
function chain(fn, m) {
  if(!isFunction(fn)) {
    throw new TypeError('chain: Chain returning function required for first argument')
  }

  if(!(isChain(m) || isArray(m))) {
    throw new TypeError('chain: Chain of the same type required for second argument')
  }

  if(isArray(m)) {
    return _chain(fn, m)
  }

  return m.chain(fn)
}

module.exports = curry(chain)


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function coalesce(f, g, m) {
  if(!isFunction(f) || !isFunction(g)) {
    throw new TypeError('coalesce: Functions required for first two arguments')
  }
  else if(!isFunction(m.coalesce)) {
    throw new TypeError('coalesce: Async, Either, Maybe or Result required for third argument')
  }

  return m.coalesce(f, g)
}

module.exports = curry(coalesce)


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */


var curry = __webpack_require__(1)
var isSameType = __webpack_require__(2)
var isSemigroup = __webpack_require__(18)
var isString = __webpack_require__(10)

function concat(x, m) {
  if(!(isSemigroup(m) && isSameType(x, m))) {
    throw new TypeError('concat: Semigroups of the same type required both arguments')
  }

  if(isString(m)) {
    return m + x
  }

  return m.concat(x)
}

module.exports = curry(concat)


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isArray = __webpack_require__(7)
var isFunction = __webpack_require__(0)

function cons(x, m) {
  if(isFunction(m.cons)) {
    return m.cons(x)
  }
  else if(isArray(m)) {
    return [ x ].concat(m)
  }

  throw new TypeError('cons: List or Array required for second argument')
}

module.exports = curry(cons)


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var compose = __webpack_require__(9)
var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

// contramap : Functor f => (b -> a) -> f b -> f a
function contramap(fn, m) {
  if(!isFunction(fn)) {
    throw new TypeError('contramap: Function required for first argument')
  }
  else if(isFunction(m)) {
    return compose(m, fn)
  }
  else if(m && isFunction(m.contramap)) {
    return m.contramap(fn)
  }
  else {
    throw new TypeError('contramap: Function or Contavariant Functor of the same type required for second requirement')
  }
}

module.exports = curry(contramap)


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function either(lf, rf, m) {
  if(!isFunction(lf) || !isFunction(rf)) {
    throw new TypeError('either: First two arguments must be functions')
  }
  else if(!(m && isFunction(m.either))) {
    throw new TypeError('either: Last argument must be an Either or Maybe')
  }

  return m.either(lf, rf)
}

module.exports = curry(either)


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

function empty(m) {
  if(m && isFunction(m.empty)) {
    return m.empty()
  }

  if(isSameType([], m)) {
    return []
  }

  if(isSameType('', m)) {
    return ''
  }

  if(isSameType({}, m)) {
    return {}
  }

  throw new TypeError('empty: Monoid, Array, String or Object required')
}

module.exports = empty


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _equals = __webpack_require__(16)
var curry = __webpack_require__(1)

function equals(x, y) {
  return _equals(x, y)
}

module.exports =
  curry(equals)


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isExtend = __webpack_require__(48)
var isFunction = __webpack_require__(0)

// extend : Extend w => (w a -> b) -> w a -> w b
function extend(fn, m) {
  if(!isFunction(fn)) {
    throw new TypeError('extend: Function required for first argument')
  }
  if(!isExtend(m)) {
    throw new TypeError('extend: Extend required for second argument')
  }

  return m.extend(fn)
}

module.exports = curry(extend)


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pred = __webpack_require__(3).proxy('Pred')

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)
var isObject = __webpack_require__(8)
var isSameType = __webpack_require__(2)
var object = __webpack_require__(22)
var predOrFunc = __webpack_require__(17)

// filter : Foldable f => (a -> Boolean) -> f a -> f a
function filter(pred, m) {
  if(!(isFunction(pred) || isSameType(Pred, pred))) {
    throw new TypeError('filter: Pred or predicate function required for first argument')
  }
  var fn =
    function (x) { return predOrFunc(pred, x); }

  if(m && isFunction(m.filter)) {
    return m.filter(fn)
  }

  if(m && isObject(m)) {
    return object.filter(fn, m)
  }

  throw new TypeError('filter: Foldable or Object required for second argument')
}

module.exports = curry(filter)


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pair = __webpack_require__(3).proxy('Pair')

var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var identity = function (x) { return x; }

function first(m) {
  if(isFunction(m)) {
    return function(x) {
      if(!isSameType(Pair, x)) {
        throw new TypeError('first: Pair required as input')
      }

      return x.bimap(m, identity)
    }
  }

  if(m && isFunction(m.first)) {
    return m.first()
  }

  throw new TypeError('first: Arrow, Function or Star required')
}

module.exports = first


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isArray = __webpack_require__(7)
var isEmpty = __webpack_require__(33)
var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)
var isSemigroup = __webpack_require__(18)

// fold : Foldable f, Semigroup s => f s -> s
function fold(m) {
  if(m && isFunction(m.fold)) {
    return m.fold()
  }

  if(isArray(m)) {
    if(isEmpty(m)) {
      throw new TypeError('fold: Non-empty Foldable with at least one Semigroup is required')
    }
    if(m.length === 1) {
      if(!isSemigroup(m[0])) {
        throw new TypeError('fold: Foldable must contain Semigroups of the same type')
      }
      return m[0]
    }

    return m.reduce(function(x, y) {
      if(!(isSemigroup(x) && isSameType(x, y))) {
        throw new TypeError('fold: Foldable must contain Semigroups of the same type')
      }
      return x.concat(y)
    })
  }

  throw new TypeError('fold: Non-empty Foldable with at least one Semigroup is required')
}

module.exports = fold


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isArray = __webpack_require__(7)
var isFunction = __webpack_require__(0)
var isString = __webpack_require__(10)

var M = __webpack_require__(14)

function head(m) {
  if(isFunction(m.head)) {
    return m.head()
  }
  else if(isArray(m) || isString(m)) {
    return !m.length
      ? M.Nothing()
      : M.Just(m[0])
  }

  throw new TypeError('head: Array, String or List required')
}

module.exports = head


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var array = __webpack_require__(15)
var compose = __webpack_require__(9)
var curry = __webpack_require__(1)
var isArray = __webpack_require__(7)
var isObject = __webpack_require__(8)
var isFunction = __webpack_require__(0)
var object = __webpack_require__(22)

// map : Functor f => (a -> b) -> f a -> f b
function map(fn, m) {
  if(!isFunction(fn)) {
    throw new TypeError('map: Function required for first argument')
  }

  if(isFunction(m)) {
    return compose(fn, m)
  }

  if(isArray(m)) {
    return array.map(fn, m)
  }

  if(m && isFunction(m.map)) {
    return m.map(fn)
  }

  if(isObject(m)) {
    return object.map(fn, m)
  }

  throw new TypeError('map: Object, Function or Functor of the same type required for second argument')
}

module.exports = curry(map)


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function option(x, m) {
  if(!(m && isFunction(m.option))) {
    throw new TypeError('option: Last argument must be a Maybe')
  }

  return m.option(x)
}

module.exports = curry(option)


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var compose = __webpack_require__(9)
var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function promap(l, r, m) {
  if(!isFunction(l) || !isFunction(r)) {
    throw new TypeError('promap: Functions required for first two arguments')
  }

  if(isFunction(m)){
    return compose(compose(r, m), l)
  }

  if(m && isFunction(m.promap)) {
    return m.promap(l, r)
  }

  throw new TypeError('promap: Function or Profunctor required for third argument')
}

module.exports = curry(promap)


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFoldable = __webpack_require__(12)
var isFunction = __webpack_require__(0)

function reduce(fn, init, m) {
  if(!isFunction(fn)) {
    throw new TypeError('reduce: Function required for first argument')
  }
  else if(!(isFoldable(m))) {
    throw new TypeError('reduce: Foldable required for third argument')
  }

  return m.reduce(fn, init)
}

module.exports = curry(reduce)


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pred = __webpack_require__(3).proxy('Pred')

var curry = __webpack_require__(1)
var isArray = __webpack_require__(7)
var isFunction = __webpack_require__(0)
var isObject = __webpack_require__(8)
var isSameType = __webpack_require__(2)
var object = __webpack_require__(22)
var predOrFunc = __webpack_require__(17)

var not =
  function (fn) { return function (x) { return !fn(x); }; }

// reject : Foldable f => (a -> Boolean) -> f a -> f a
function reject(pred, m) {
  if(!(isFunction(pred) || isSameType(Pred, pred))) {
    throw new TypeError('reject: Pred or predicate function required for first argument')
  }

  var fn =
    function (x) { return predOrFunc(pred, x); }

  if(m && isFunction(m.reject)) {
    return m.reject(fn)
  }

  if(isArray(m)) {
    return m.filter(not(fn))
  }

  if(isObject(m)) {
    return object.filter(not(fn), m)
  }

  throw new TypeError('reject: Foldable or Object required for second argument')
}

module.exports = curry(reject)


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

function run(m) {
  if(!(m && isFunction(m.run))) {
    throw new TypeError('run: IO required')
  }

  return m.run()
}

module.exports = run


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function runWith(x, m) {
  if(!(m && isFunction(m.runWith))) {
    throw new TypeError('runWith: Arrow, Reader, Star or State required for second argument')
  }

  return m.runWith(x)
}

module.exports = curry(runWith)


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var Pair = __webpack_require__(3).proxy('Pair')

var isFunction = __webpack_require__(0)
var isSameType = __webpack_require__(2)

var identity = function (x) { return x; }

function second(m) {
  if(isFunction(m)) {
    return function(x) {
      if(!isSameType(Pair, x)) {
        throw new TypeError('first: Pair required as input')
      }

      return x.bimap(identity, m)
    }
  }

  if(m && isFunction(m.second)) {
    return m.second()
  }

  throw new TypeError('second: Arrow, Function or Star required')
}

module.exports = second


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var array = __webpack_require__(15)
var curry = __webpack_require__(1)
var isArray = __webpack_require__(7)
var isFunction = __webpack_require__(0)

function sequence(af, m) {
  if(!isFunction(af)) {
    throw new TypeError('sequence: Applicative function required for first argument')
  }

  if((m && isFunction(m.sequence))) {
    return m.sequence(af)
  }

  if((isArray(m))) {
    return array.sequence(af, m)
  }

  throw new TypeError('sequence: Traversable or Array required for second argument')
}

module.exports = curry(sequence)


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isFunction = __webpack_require__(0)

function swap(f, g, m) {
  if(!isFunction(f) || !isFunction(g)) {
    throw new TypeError('swap: Function required for first two arguments')
  }
  else if(!isFunction(m.swap)) {
    throw new TypeError('swap: Either or Pair required for third arguments')
  }

  return m.swap(f, g)
}

module.exports = curry(swap)


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isFunction = __webpack_require__(0)

var M = __webpack_require__(14)

function tail(m) {
  if(isFunction(m.tail)) {
    return m.tail()
  }
  else if(isFunction(m.slice)) {
    return m.length < 2
      ? M.Nothing()
      : M.Just(m.slice(1))
  }

  throw new TypeError('tail: Array, String or List required')
}

module.exports = tail


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var array = __webpack_require__(15)
var curry = __webpack_require__(1)
var isArray = __webpack_require__(7)
var isFunction = __webpack_require__(0)

function traverse(af, fn, m) {
  if(!isFunction(af)) {
    throw new TypeError('traverse: Applicative function required for first argument')
  }

  if(!isFunction(fn)) {
    throw new TypeError('traverse: Applicative returning function required for second argument')
  }

  if((m && isFunction(m.traverse))) {
    return m.traverse(af, fn)
  }

  if((isArray(m))) {
    return array.traverse(af, fn, m)
  }

  throw new TypeError('traverse: Traversable or Array required for third argument')
}

module.exports = curry(traverse)


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isNil = __webpack_require__(11)

function valueOf(m) {
  if(isNil(m)) {
    return m
  }

  return m.valueOf()
}

module.exports = valueOf


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var curry = __webpack_require__(1)
var isString = __webpack_require__(10)
var isInteger = __webpack_require__(34)

// hasProp : (String | Number) -> a -> Boolean
function hasProp(key, x) {
  if(!(isString(key) || isInteger(key))) {
    throw new TypeError('hasProp: Number or String required for first argument')
  }

  return (!!x && x[key] !== undefined)
}

module.exports = curry(hasProp)


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(40)


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isApplicative = __webpack_require__(13)
var isPlus = __webpack_require__(50)

// isAlternative : a -> Boolean
function isAlternative(m) {
  return isPlus(m)
    && isApplicative(m)
}

module.exports = isAlternative


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(13)


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(29)


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(7)


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(224)


/***/ }),
/* 198 */
/***/ (function(module, exports) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

// isBoolean : a -> Boolean
function isBoolean(x) {
  return typeof x === 'boolean'
}

module.exports = isBoolean


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isSemigroupoid = __webpack_require__(30)

// isCategory : a -> Boolean
function isCategory(m) {
  return isSemigroupoid(m)
    && hasAlg('id', m)
}

module.exports = isCategory


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(32)


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(41)


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(42)


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(33)


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(48)


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(12)


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(0)


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(20)


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(34)


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(49)


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(25)


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(11)


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(21)


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(8)


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(50)


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isContravariant = __webpack_require__(41)
var isFunctor = __webpack_require__(20)

// isProfunctor : a -> Boolean
function isProfunctor(m) {
  return isFunctor(m)
    && isContravariant(m)
    && hasAlg('promap', m)
}

module.exports = isProfunctor


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(35)


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(51)


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(2)


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(18)


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(30)


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)

// isSetoid : a -> Boolean
function isSetoid(m) {
  return !!m
    && hasAlg('equals', m)
}

module.exports = isSetoid



/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

module.exports =
  __webpack_require__(10)


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isFunctor = __webpack_require__(20)

// isTraversable : a -> Boolean
function isTraversable(m) {
  return isFunctor(m)
    && hasAlg('traverse', m)
}

module.exports = isTraversable


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var hasAlg = __webpack_require__(6)
var isFunctor = __webpack_require__(20)

// isBifunctor : a -> Boolean
function isBifunctor(m) {
  return isFunctor(m)
    && hasAlg('bimap', m)
}

module.exports = isBifunctor


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var combinators = {
  applyTo: __webpack_require__(114),
  composeB: __webpack_require__(115),
  constant: __webpack_require__(116),
  flip: __webpack_require__(117),
  identity: __webpack_require__(118),
  reverseApply: __webpack_require__(119),
  substitution: __webpack_require__(120)
}

var crocks = {
  Arrow: __webpack_require__(56),
  Async: __webpack_require__(23),
  Const: __webpack_require__(63),
  Either: __webpack_require__(26),
  Identity: __webpack_require__(74),
  IO: __webpack_require__(73),
  List: __webpack_require__(37),
  Maybe: __webpack_require__(38),
  Pair: __webpack_require__(92),
  Pred: __webpack_require__(97),
  Reader: __webpack_require__(99),
  Result: __webpack_require__(24),
  Star: __webpack_require__(105),
  State: __webpack_require__(108),
  Unit: __webpack_require__(110),
  Writer: __webpack_require__(111)
}

var helpers = {
  assign: __webpack_require__(121),
  assoc: __webpack_require__(122),
  binary: __webpack_require__(123),
  branch: __webpack_require__(90),
  compose: __webpack_require__(124),
  composeK: __webpack_require__(125),
  composeP: __webpack_require__(126),
  composeS: __webpack_require__(127),
  curry: __webpack_require__(128),
  defaultProps: __webpack_require__(129),
  defaultTo: __webpack_require__(130),
  dissoc: __webpack_require__(131),
  fanout: __webpack_require__(132),
  fromPairs: __webpack_require__(133),
  liftA2: __webpack_require__(134),
  liftA3: __webpack_require__(135),
  mapProps: __webpack_require__(136),
  mapReduce: __webpack_require__(137),
  mconcat: __webpack_require__(138),
  mconcatMap: __webpack_require__(139),
  mreduce: __webpack_require__(140),
  mreduceMap: __webpack_require__(141),
  nAry: __webpack_require__(142),
  objOf: __webpack_require__(143),
  omit: __webpack_require__(144),
  once: __webpack_require__(145),
  partial: __webpack_require__(146),
  pick: __webpack_require__(147),
  pipe: __webpack_require__(148),
  pipeK: __webpack_require__(149),
  pipeP: __webpack_require__(150),
  pipeS: __webpack_require__(151),
  prop: __webpack_require__(85),
  propPath: __webpack_require__(86),
  safe: __webpack_require__(43),
  safeLift: __webpack_require__(88),
  tap: __webpack_require__(152),
  toPairs: __webpack_require__(95),
  tryCatch: __webpack_require__(104),
  unary: __webpack_require__(153),
  unit: __webpack_require__(154)
}

var logic = {
  and: __webpack_require__(155),
  ifElse: __webpack_require__(156),
  not: __webpack_require__(157),
  or: __webpack_require__(158),
  unless: __webpack_require__(159),
  when: __webpack_require__(160)
}

var monoids = {
  All: __webpack_require__(54),
  Any: __webpack_require__(55),
  Assign: __webpack_require__(57),
  Endo: __webpack_require__(68),
  First: __webpack_require__(27),
  Last: __webpack_require__(28),
  Max: __webpack_require__(81),
  Min: __webpack_require__(89),
  Prod: __webpack_require__(98),
  Sum: __webpack_require__(109),
}

var pointfree = {
  alt: __webpack_require__(161),
  ap: __webpack_require__(162),
  bimap: __webpack_require__(163),
  both: __webpack_require__(164),
  chain: __webpack_require__(165),
  coalesce: __webpack_require__(166),
  concat: __webpack_require__(167),
  cons: __webpack_require__(168),
  contramap: __webpack_require__(169),
  either: __webpack_require__(170),
  empty: __webpack_require__(171),
  equals: __webpack_require__(172),
  evalWith: __webpack_require__(106),
  execWith: __webpack_require__(107),
  extend: __webpack_require__(173),
  filter: __webpack_require__(174),
  first: __webpack_require__(175),
  fold: __webpack_require__(176),
  fst: __webpack_require__(91),
  head: __webpack_require__(177),
  log: __webpack_require__(112),
  map: __webpack_require__(178),
  merge: __webpack_require__(93),
  option: __webpack_require__(179),
  promap: __webpack_require__(180),
  read: __webpack_require__(113),
  reduce: __webpack_require__(181),
  reject: __webpack_require__(182),
  run: __webpack_require__(183),
  runWith: __webpack_require__(184),
  second: __webpack_require__(185),
  sequence: __webpack_require__(186),
  snd: __webpack_require__(94),
  swap: __webpack_require__(187),
  tail: __webpack_require__(188),
  traverse: __webpack_require__(189),
  valueOf: __webpack_require__(190)
}

var predicates = {
  hasProp: __webpack_require__(191),
  isAlt: __webpack_require__(192),
  isAlternative: __webpack_require__(193),
  isApplicative: __webpack_require__(194),
  isApply: __webpack_require__(195),
  isArray: __webpack_require__(196),
  isBifunctor: __webpack_require__(197),
  isBoolean: __webpack_require__(198),
  isCategory: __webpack_require__(199),
  isChain: __webpack_require__(200),
  isContravariant: __webpack_require__(201),
  isDefined: __webpack_require__(202),
  isEmpty: __webpack_require__(203),
  isExtend: __webpack_require__(204),
  isFoldable: __webpack_require__(205),
  isFunction: __webpack_require__(206),
  isFunctor: __webpack_require__(207),
  isInteger: __webpack_require__(208),
  isMonad: __webpack_require__(209),
  isMonoid: __webpack_require__(210),
  isNil: __webpack_require__(211),
  isNumber: __webpack_require__(212),
  isObject: __webpack_require__(213),
  isPlus: __webpack_require__(214),
  isProfunctor: __webpack_require__(215),
  isPromise: __webpack_require__(216),
  isSame: __webpack_require__(217),
  isSameType: __webpack_require__(218),
  isSemigroup: __webpack_require__(219),
  isSemigroupoid: __webpack_require__(220),
  isSetoid: __webpack_require__(221),
  isString: __webpack_require__(222),
  isTraversable: __webpack_require__(223)
}

var transforms = {
  arrayToList: __webpack_require__(79),
  eitherToAsync: __webpack_require__(58),
  eitherToFirst: __webpack_require__(69),
  eitherToLast: __webpack_require__(75),
  eitherToMaybe: __webpack_require__(82),
  eitherToResult: __webpack_require__(100),
  firstToAsync: __webpack_require__(59),
  firstToEither: __webpack_require__(64),
  firstToLast: __webpack_require__(76),
  firstToMaybe: __webpack_require__(83),
  firstToResult: __webpack_require__(101),
  lastToAsync: __webpack_require__(60),
  lastToEither: __webpack_require__(65),
  lastToFirst: __webpack_require__(70),
  lastToMaybe: __webpack_require__(84),
  lastToResult: __webpack_require__(102),
  listToArray: __webpack_require__(80),
  maybeToAsync: __webpack_require__(61),
  maybeToEither: __webpack_require__(66),
  maybeToFirst: __webpack_require__(71),
  maybeToLast: __webpack_require__(77),
  maybeToResult: __webpack_require__(103),
  resultToAsync: __webpack_require__(62),
  resultToEither: __webpack_require__(67),
  resultToFirst: __webpack_require__(72),
  resultToLast: __webpack_require__(78),
  resultToMaybe: __webpack_require__(87),
  writerToPair: __webpack_require__(96)
}

module.exports = Object.assign(
  {},
  combinators,
  crocks,
  helpers,
  logic,
  monoids,
  pointfree,
  predicates,
  transforms
)


/***/ })
/******/ ]);
});