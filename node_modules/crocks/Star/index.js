/** @license ISC License (c) copyright 2016 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var _implements = require('../core/implements')
var _inspect = require('../core/inspect')
var _type = require('../core/types').type('Star')

var array = require('../core/array')
var isFunction = require('../core/isFunction')
var isMonad = require('../core/isMonad')
var isSameType = require('../core/isSameType')

var Pair = require('../core/Pair')

var merge =
  function (fn, m) { return m.merge(fn); }

var sequence =
  function (af, m) { return array.sequence(af, m); }

function _Star(Monad) {
  if(!isMonad(Monad)) {
    throw new TypeError('Star: Monad required for construction')
  }

  var _id =
    function () { return Star(Monad.of); }

  var innerType =
    Monad.type()

  var outerType =
    (_type()) + "( " + innerType + " )"

  var type =
    function () { return outerType; }

  function Star(runWith) {
    if(!isFunction(runWith)) {
      throw new TypeError((outerType + ": Function in the form (a -> m b) required"))
    }

    var inspect =
      function () { return ("" + outerType + (_inspect(runWith))); }

    var id =
      _id

    function compose(s) {
      if(!isSameType(Star, s)) {
        throw new TypeError((outerType + ".compose: " + outerType + " required"))
      }

      return Star(function(x) {
        var m = runWith(x)

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".compose: Computations must return a type of " + innerType))
        }

        return m.chain(function(val) {
          var inner = s.runWith(val)

          if(!isSameType(m, inner)) {
            throw new TypeError((outerType + ".compose: Both computations must return a type of " + innerType))
          }

          return inner
        })
      })
    }

    function map(fn) {
      if(!isFunction(fn)) {
        throw new TypeError((outerType + ".map: Function required"))
      }

      return Star(function(x) {
        var m = runWith(x)

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".map: Computations must return a type of " + innerType))
        }

        return m.map(fn)
      })
    }

    function contramap(fn) {
      if(!isFunction(fn)) {
        throw new TypeError((outerType + ".contramap: Function required"))
      }

      return Star(function (x) { return runWith(fn(x)); })
    }

    function promap(l, r) {
      if(!isFunction(l) || !isFunction(r)) {
        throw new TypeError((outerType + ".promap: Functions required for both arguments"))
      }

      return Star(function(x) {
        var m = runWith(l(x))

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".promap: Computation must return a type of " + innerType))
        }

        return m.map(r)
      })
    }

    function first() {
      return Star(function(x) {
        if(!isSameType(Pair, x)) {
          throw TypeError((outerType + ".first: Pair required for computation input"))
        }

        var m = runWith(x.fst())

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".first: Computation must return a type of " + innerType))
        }

        return m.map(function (l) { return Pair(l, x.snd()); })
      })
    }

    function second() {
      return Star(function(x) {
        if(!isSameType(Pair, x)) {
          throw TypeError((outerType + ".second: Pair required for computation input"))
        }

        var m = runWith(x.snd())

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".second: Computation must return a type of " + innerType))
        }

        return m.map(function (r) { return Pair(x.fst(), r); })
      })
    }

    function both() {
      return Star(function(x) {
        if(!isSameType(Pair, x)) {
          throw TypeError((outerType + ".both: Pair required for computation input"))
        }

        var p = x.bimap(runWith, runWith)
        var m = p.fst()

        if(!isSameType(Monad, m)) {
          throw new TypeError((outerType + ".both: Computation must return a type of " + innerType))
        }

        return sequence(m.of, merge(function (x, y) { return [ x, y ]; }, p)).map(function (x) { return Pair(x[0], x[1]); })
      })
    }

    return {
      inspect: inspect, type: type, runWith: runWith,
      id: id, compose: compose, map: map, contramap: contramap,
      promap: promap, first: first, second: second, both: both
    }
  }

  Star.id = _id
  Star.type = type

  Star['@@implements'] = _implements(
    [ 'compose', 'contramap', 'id', 'map', 'promap' ]
  )

  return Star
}

module.exports = _Star
