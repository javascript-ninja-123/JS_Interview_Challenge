/** @license ISC License (c) copyright 2017 original and current authors */
/** @author Ian Hofmann-Hicks (evil) */

var isApplicative = require('./isApplicative')
var isArray = require('./isArray')
var isFunction = require('./isFunction')

var identity = function (x) { return x; }

var concat =
  function (x) { return function (m) { return m.concat(x); }; }

function runTraverse(name, fn) {
  return function(acc, x) {
    var m = fn(x)

    if(!isApplicative(acc) || !isApplicative(m)) {
      throw new TypeError(("Array." + name + ": Must wrap Applicatives"))
    }

    return m
      .map(function (v) { return concat([ v ]); })
      .ap(acc)
  }
}

var allFuncs =
  function (xs) { return xs.reduce(function (b, i) { return b && isFunction(i); }, true); }

var map =
  function (f, m) { return m.map(function (x) { return f(x); }); }

function ap(x, m) {
  if(!(m.length && allFuncs(m))) {
    throw new TypeError('Array.ap: Second Array must all be functions')
  }

  return m.reduce(function (acc, f) { return acc.concat(map(f, x)); }, [])
}

function chain(f, m) {
  return m.reduce(function(y, x) {
    var n = f(x)

    if(!isArray(n)) {
      throw new TypeError('Array.chain: Function must return an Array')
    }

    return y.concat(n)
  }, [])
}

function sequence(af, m) {
  return m.reduce(runTraverse('sequence', identity), af([]))
}

function traverse(af, fn, m) {
  return m.reduce(runTraverse('traverse', fn), af([]))
}

module.exports = {
  ap: ap, chain: chain, map: map, sequence: sequence, traverse: traverse
}
